<!DOCTYPE html>
<html>
  <head>
  <title></title>
  <meta charset="utf-8" />
  <link rel="icon" href="/favicon.jpg " type="image/x-icon" />

  
<link rel="stylesheet" href="../../../css/index.css">

</head>

  <body>
    <div class="nav-layout">
    <div class="nav-content">
        <div class="nav-header">
    <span>目录</span>
    <div></div>
</div> 
        <ul class="nav-categories">

 
    <li class="nav-item">
        <a href="http://localhost:4000/categories/博客 ">博客 </a>
    </li>
 

 
    <li class="nav-item">
        <a href="http://localhost:4000/categories/笔记 ">笔记 </a>
    </li>
 

 

 

 

 

 

</ul>
    </div>
</div> 

    <div class="header">
    <div class="avatar">
    <img src="/img/avatar.jpg " alt="twowind" />
</div> 
    <div class="logo">
        twowind
    </div>
    <div class="menu">
  <input type="checkbox" id="burger-toggle" />
  <label for="burger-toggle" class="burger-menu">
    <div class="line"></div>
    <div class="line"></div>
    <div class="line"></div>
  </label>
  <div class="switch_background"></div>
</div>
 
</div>



    <div class="post">
    <div>

    </div>
    <div class="post-content">
        <div class="markdown-body">
        <h1 id="1-JavaScript"><a href="#1-JavaScript" class="headerlink" title="1. JavaScript"></a>1. JavaScript</h1><h2 id="1-JavaScript历史"><a href="#1-JavaScript历史" class="headerlink" title="1. JavaScript历史"></a>1. JavaScript历史</h2><h3 id="1-1-与ECMAScript的关系"><a href="#1-1-与ECMAScript的关系" class="headerlink" title="1.1. 与ECMAScript的关系"></a>1.1. 与ECMAScript的关系</h3><p>ECMAScript 是 JavaScript 语言的规范标准，JavaScript 是 ECMAScript 的一种实现。注意，这两个词在一般语境中是可以互换的。</p>
<h3 id="1-2-JavaScript构成"><a href="#1-2-JavaScript构成" class="headerlink" title="1.2. JavaScript构成"></a>1.2. JavaScript构成</h3><ul>
<li>核心（ECMAScript）：语言核心部分。</li>
<li>文档对象模型（Document Object Model，DOM）：网页文档操作标准。</li>
<li>浏览器对象模型（BOM）：客户端和浏览器窗口操作基础。</li>
</ul>
<h2 id="2-基础知识"><a href="#2-基础知识" class="headerlink" title="2. 基础知识"></a>2. 基础知识</h2><h3 id="2-1-引入使用"><a href="#2-1-引入使用" class="headerlink" title="2.1. 引入使用"></a>2.1. 引入使用</h3><h4 id="1-在HTML中使用"><a href="#1-在HTML中使用" class="headerlink" title="1 在HTML中使用"></a>1 在HTML中使用</h4><p>在script写JavaScript代码，为 &lt;script&gt; 标签设置type=”text/javascript”属性</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;&lt;h1&gt;Hi,JavaScript!&lt;/h1&gt;&quot;</span>);</span>
<span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>

<h4 id="2-使用单独的JavaScript文件"><a href="#2-使用单独的JavaScript文件" class="headerlink" title="2. 使用单独的JavaScript文件"></a>2. 使用单独的JavaScript文件</h4><p>JavaScript的文件后缀为<code>.js</code></p>
<p>js文件不能单独使用，需要导入到网页中，通过浏览器执行，导入也是使用<code>&lt;script&gt;</code>标签，type属性不变，src属性值为js文件的路径</p>
<blockquote>
<p>注意：使用＜script＞标签包含外部 JavaScript 文件时，默认文件类型为 Javascript。因此，不管加载的文件扩展名是不是 .js，浏览器都会按 JavaScript 脚本来解析。</p>
</blockquote>
<p>定义 src 属性的&lt;script&gt; 标签不应再包含 JavaScript 代码。如果嵌入了代码，则只会下载并执行外部 JavaScript 文件，<code>嵌入代码将被忽略</code>。</p>
<h4 id="3-文件延迟和异步加载"><a href="#3-文件延迟和异步加载" class="headerlink" title="3. 文件延迟和异步加载"></a>3. 文件延迟和异步加载</h4><p>由于html文件加载的循序性，&lt;script&gt;标签会被放在head里面。如此，浏览器会首先加载js文件，只有等js代码被加载、解析、执行完毕之后才会解析html文件，如果js文件过大html解析就容易产生”滞后“，这种效应就被称为”<code>阻塞效应“</code>。<code>所以建议将JavaScript文件放在head标签后面</code></p>
<h5 id="1-延迟执行JavaScript文件"><a href="#1-延迟执行JavaScript文件" class="headerlink" title="1. 延迟执行JavaScript文件"></a>1. 延迟执行JavaScript文件</h5><p>&lt;script&gt;标签有一个布尔型属性 <strong>defer</strong>，设置该属性能够将 JavaScript 文件延迟到页面解析完毕后再运行。</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;test.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>

<blockquote>
<p>注意：defer 属性适用于外部 JavaScript 文件，不适用于 &lt;script&gt;签包含的 JavaScript 脚本。</p>
</blockquote>
<h5 id="2-异步加载JavaScript文件"><a href="#2-异步加载JavaScript文件" class="headerlink" title="2. 异步加载JavaScript文件"></a>2. 异步加载JavaScript文件</h5><p>现在可以为 &lt;script&gt; 标签设置 <strong>async</strong> 属性，让浏览器异步加载 JavaScript 文件，即在加载 JavaScript 文件时，浏览器不会暂停，而是继续解析。这样能节省时间，提升响应速度。</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;test.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>

<p>async 是 HTML5 新增的布尔型属性，通过设置 async 属性，就不用考虑 &lt;script&gt; 标签的放置位置，用户可以根据习惯继续把很多大型 JavaScript 库文件放在 &lt;head&gt; 标签内。</p>
<h4 id="4-JavaScript字符编码"><a href="#4-JavaScript字符编码" class="headerlink" title="4. JavaScript字符编码"></a>4. JavaScript字符编码</h4><p>JavaScript 遵循 Unicode 字符编码规则(可以使用中文，但不建议)。</p>
<blockquote>
<p>由于 JavaScript 脚本一般都嵌入在网页中，并最终由浏览器来解释，因此在考虑到 JavaScript 字符编码的同时， 还要兼顾 HTML 文档的字符编码，以及浏览器支持的编码。一般建议保持 HTML 文档的字符编码与 JavaScript 字符编码一致，以免出现乱码。</p>
</blockquote>
<h3 id="2-2-语句"><a href="#2-2-语句" class="headerlink" title="2.2. 语句"></a>2.2. 语句</h3><p>尽管大多数的时候，当换行符存在的时候可以省略分号，但是仍然有少部分的情况下会引起未知的错误。</p>
<pre><code class="hljs js"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;There will be an error&quot;</span>)

[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].<span class="hljs-title function_">forEach</span>(alert)

<span class="hljs-comment">// 实际解析</span>
<span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;There will be an error&quot;</span>)[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].<span class="hljs-title function_">forEach</span>(alert)</code></pre>

<h4 id="1-JavaScript代码块"><a href="#1-JavaScript代码块" class="headerlink" title="1. JavaScript代码块"></a>1. JavaScript代码块</h4><p>不同script标签下的代码块由于加载的顺序性，只有等上一个代码块加载、解析、执行完毕之后才会加载下一个代码块。尽管如此不同的代码块仍属于相同的作用域（全局作用域）。</p>
<p>例如：以下代码会出现错误</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript">    <span class="hljs-comment">//JavaScript 代码块 1</span></span>
<span class="language-javascript">    <span class="hljs-title function_">alert</span>(a);</span>
<span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript">    <span class="hljs-comment">//JavaScript 代码块 2</span></span>
<span class="language-javascript">    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;</span>
<span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>

<p>而以下却不会</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript">    <span class="hljs-comment">//JavaScript 代码块 2</span></span>
<span class="language-javascript">    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;</span>
<span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript">    <span class="hljs-comment">//JavaScript 代码块 1</span></span>
<span class="language-javascript">    <span class="hljs-title function_">alert</span>(a);</span>
<span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>

<h4 id="2-注释"><a href="#2-注释" class="headerlink" title="2. 注释"></a>2. 注释</h4><ul>
<li>单行注释：//单行注释信息。</li>
<li>多行注释：/*多行注释信息*/</li>
</ul>
<h4 id="3-严格模式"><a href="#3-严格模式" class="headerlink" title="3. 严格模式"></a>3. 严格模式</h4><p>ECMAscript5 新增了严格运行模式。推出严格模式的目的如下：</p>
<ul>
<li>消除 JavaScript 语法中不合理、不严谨的用法。</li>
<li>消除代码运行的一些安全隐患。</li>
<li>提高编译器效率，提升程序运行速度。</li>
<li>为未来新版本的规范化做好铺垫。</li>
</ul>
<blockquote>
<p>一旦启用严格模式，那么开弓没有回头箭</p>
</blockquote>
<h5 id="1-启用严格模式"><a href="#1-启用严格模式" class="headerlink" title="1. 启用严格模式"></a>1. 启用严格模式</h5><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>
<span class="hljs-comment">// 必须在首部中使用，否则视为无效。所谓首部就是前面没有任何有效js代码</span></code></pre>

<blockquote>
<p>不支持严格模式的浏览器会把它作为字符串直接量忽略掉。</p>
</blockquote>
<h5 id="2-严格模式的应用场景"><a href="#2-严格模式的应用场景" class="headerlink" title="2. 严格模式的应用场景"></a>2. 严格模式的应用场景</h5><p>==全局模式==</p>
<p>将 “use strict” 放在脚本文件的第一行，则整个脚本都将以严格模式运行。如果不在第一行，则整个脚本将以正常模式运行。</p>
<p>在不同&lt;script&gt;代码块中并<code>不是互通</code>的，即第一个&lt;script&gt;代码块启用，第二个&lt;script&gt;代码块并不会生效</p>
<p>==局部模式==</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">strict</span>(<span class="hljs-params"></span>)&#123;
    <span class="hljs-string">&quot;use strict&quot;</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;这是严格模式。&quot;</span>;
&#125;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">notStrict</span>(<span class="hljs-params"></span>)&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;这是正常模式。&quot;</span>;
&#125;</code></pre>

<blockquote>
<p>全局模式不利于 JavaScript 文件合并。例如，如果一个开启了严格模式的 JavaScript 库，被导入到一个正常模式的网页脚本中，由于无法确保 “use strict” 位于脚本的首部位置，容易导致严格模式失效。因此，推荐的最佳实践是使用局部模式，将整个 JavaScript 文件脚本放在一个立即执行的匿名函数中，在匿名函数内启动严格模式。当 JavaScript 库文件被导入到不同模式的网页中，就不用担心严格模式失效了。</p>
</blockquote>
<pre><code class="hljs javascript">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;
    <span class="hljs-string">&quot;use strict&quot;</span>;
    <span class="hljs-comment">// JavaScript库文件 代码</span>
&#125;) ();</code></pre>

<h3 id="2-3-变量"><a href="#2-3-变量" class="headerlink" title="2.3. 变量"></a>2.3. 变量</h3><p>在非严格模式下，JavaScript 允许不声明变量就直接为其赋值，这是因为 JavaScript 解释器能够自动隐式声明变量。隐式声明的变量总是作为全局变量使用。在严格模式下，变量必须先声明，然后才能使用。</p>
<blockquote>
<p><code>变量提升：JavaScript 在预编译期会先预处理声明的变量，但是变量的赋值操作发生在 JavaScript 执行期，而不是预编译期。</code></p>
</blockquote>
<blockquote>
<p><code>let不会进行声明提升 ! ！会直接发生编译错误</code></p>
</blockquote>
<h4 id="1-变量作用域"><a href="#1-变量作用域" class="headerlink" title="1. 变量作用域"></a>1. 变量作用域</h4><ul>
<li>全局变量：变量在整个页面脚本中都是可见的，可以被自由访问。<ul>
<li>在任何函数体外直接使用 var 语句声明。</li>
<li>直接添加属性到全局对象上。在 Web 浏览器中，全局作用域对象为 window。</li>
<li>直接使用未经声明的变量，以这种方式定义的全局变量被称为隐式的全局变量。</li>
</ul>
</li>
<li>局部变量：变量仅能在声明的函数内部可见，函数外是不允许访问的。</li>
</ul>
<h4 id="2-变量污染"><a href="#2-变量污染" class="headerlink" title="2. 变量污染"></a>2. 变量污染</h4><p>全局变量在全局作用域内都是可见的，因此具有污染性。大量使用全局变量会降低程序的可靠性，用户应该避免使用全局变量。</p>
<p>解决方法：</p>
<p><strong>在脚本中创建一个全局变量，作为当前应用的唯一接口，然后通过对象直接量的形式包含所有应用程序变量。</strong></p>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">MyAPP</span> = &#123;&#125;; <span class="hljs-comment">//定义 APP 访问接口</span>
<span class="hljs-title class_">MyAPP</span>.<span class="hljs-property">name</span> = &#123; <span class="hljs-comment">//定义APP配置变量</span>
    <span class="hljs-string">&quot;id&quot;</span> : <span class="hljs-string">&quot;应用程序的ID编号&quot;</span>
&#125;;
<span class="hljs-title class_">MyAPP</span>.<span class="hljs-property">work</span> = &#123;
    num : <span class="hljs-number">123</span>,  <span class="hljs-comment">//APP计数器等内部属性</span>
    sub : &#123; name : <span class="hljs-string">&quot;sub_id&quot;</span>&#125;, <span class="hljs-comment">//APP应用分支</span>
    doing : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-comment">//具体方法</span>
        <span class="hljs-comment">//执行代码</span>
    &#125;
&#125;;</code></pre>

<blockquote>
<p>把应用程序的所有变量都追加在该唯一名称空间下，降低与其他应用程序相互冲突的概率，应用程序也会变得更容易阅读。</p>
</blockquote>
<p><strong>使用函数体封装应用程序，这是最常用的一种方法。</strong></p>
<pre><code class="hljs javascript">(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;
    <span class="hljs-keyword">var</span> <span class="hljs-title class_">MyAPP</span> = &#123;&#125;;  <span class="hljs-comment">//定义 APP 访问接口</span>
    <span class="hljs-title class_">MyAPP</span>.<span class="hljs-property">name</span> = &#123;  <span class="hljs-comment">//定义APP配置变量</span>
        <span class="hljs-string">&quot;id&quot;</span> : <span class="hljs-string">&quot;应用程序的ID编号&quot;</span>
    &#125;;
    <span class="hljs-title class_">MyAPP</span>.<span class="hljs-property">work</span> = &#123;
        num : <span class="hljs-number">123</span>,  <span class="hljs-comment">//APP计数器等内部属性</span>
        sub : &#123; name : <span class="hljs-string">&quot;sub_id&quot;</span>&#125;,  <span class="hljs-comment">//APP 应用分支</span>
        doing : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-comment">//具体方法</span>
            <span class="hljs-comment">//执行代码</span>
        &#125;
    &#125;;
    <span class="hljs-variable language_">window</span>.<span class="hljs-property">MyAPP</span>;  <span class="hljs-comment">//对外开放应用程序接口</span>
&#125;)(<span class="hljs-variable language_">window</span>)</code></pre>

<p>在 JavaScript 函数体内，所有声明的私有变量、参数、内部函数对外都是不可见的，如果不主动开放，外界是无法访问内部数据的，因此使用函数体封装应用程序是最佳实践。</p>
<blockquote>
<p>使用var可以重复声明，但是let无法重复声明</p>
</blockquote>
<blockquote>
<p>变量尽量进行<code>新建</code>而非<code>重用</code>，看起来这存在性能丢失，但是现代编译器经过优化基本上不会产生性能问题。另外<code>新建</code>的最大好处是不用担心它在其它地方被更改而遗忘造成以后调试的困难。</p>
</blockquote>
<h4 id="3-常量"><a href="#3-常量" class="headerlink" title="3. 常量"></a>3. 常量</h4><p>关键字”const“，常量的命名尽量使用大写</p>
<h3 id="2-4-数据类型"><a href="#2-4-数据类型" class="headerlink" title="2.4. 数据类型"></a>2.4. 数据类型</h3><ul>
<li>简单的值（原始值）：包含字符串、数字和布尔值，此外，还有两个特殊值——null（空值）和 undefined（为定义）。</li>
<li>复杂的数据结构（泛指对象）：包括狭义的对象、数组和函数。</li>
</ul>
<p>使用<code>typeof</code>运算符可以查看值的数据类型</p>
<p>注意：</p>
<ul>
<li>把 null 归为 Object 类型，而不是作为一种特殊类型（Null）的值。</li>
<li>把 function(,){} 归为 Function 类型。即把函数视为一种独立的基本数据类型，而不是 Object 类型的一种特殊子类。</li>
</ul>
<blockquote>
<p>在 JavaScript 中，函数是一种比较特殊的结构。它可以是一段代码集合，也可以是一种数据类型；可以作为对象来使用，还可以作为构造函数创建类型。JavaScript 函数的用法比较灵活，这也是 JavaScript 语言敏捷的一种表现（函数式编程）。</p>
</blockquote>
<h4 id="1-Number"><a href="#1-Number" class="headerlink" title="1. Number"></a>1. Number</h4><p>除了常规的数字外还有一些”<code>特殊数值</code>“：</p>
<ul>
<li>Infinity：无穷大，可以通过除法获得也可以使用该关键字</li>
<li>-Infinity：</li>
<li>NaN：代表计算错误，一个不正确或未定义的数学操作所获得的结果，例如字符串除以数字</li>
</ul>
<p>typeof 不能分辨数字和 NaN，并且 NaN 不等同于它自己。</p>
<pre><code class="hljs javascript"><span class="hljs-title class_">NaN</span> === <span class="hljs-title class_">NaN</span> <span class="hljs-comment">//false</span>
<span class="hljs-title class_">NaN</span> !== <span class="hljs-title class_">NaN</span> <span class="hljs-comment">//true</span></code></pre>

<p>使用 isNaN() 全局函数可以判断 NaN。</p>
<p>使用 isFinite() 全局函数可以判断 NaN 和 Infinity</p>
<table>
<thead>
<tr>
<th>特殊值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Infinity</td>
<td>无穷大。当数值超过浮点型所能够表示的范围；反之，负无穷大为-Infinity</td>
</tr>
<tr>
<td>NaN</td>
<td>非数值。不等于任何数值，包括自己。如当0除以0时会返回这个特殊值</td>
</tr>
<tr>
<td>Number.MAX_VALUE</td>
<td>表示最大数值</td>
</tr>
<tr>
<td>Number.MIN_VALUE</td>
<td>表示最小数值，一个接近0的值</td>
</tr>
<tr>
<td>Number.NaN</td>
<td>非数值，与NaN常量相同</td>
</tr>
<tr>
<td>Number.POSITIVE_INFINITY</td>
<td>表示正无穷大的数值</td>
</tr>
<tr>
<td>Number.NEGATIVE_INFINITY</td>
<td>表示负无穷大的数值</td>
</tr>
</tbody></table>
<blockquote>
<p>NaN（Not a Number，非数字值）是在 IEEE 754 中定义的一个特殊的数值。</p>
<p>当试图将非数字形式的字符串转换为数字时，就会生成 NaN。</p>
<p>当 NaN 参与数学运算时，运算结果也是 NaN。</p>
</blockquote>
<p>因此，可以使用它来检测 NaN、正负无穷大。如果是有限数值，或者可以转换为有限数值，那么将返回 true。如果只是 NaN、正负无穷大的数值，则返回 false 。</p>
<blockquote>
<p>数学运算时永远安全的</p>
</blockquote>
<h4 id="2-BigInt"><a href="#2-BigInt" class="headerlink" title="2. BigInt"></a>2. BigInt</h4><p>可以通过将 <code>n</code> 附加到整数字段的末尾来创建 <code>BigInt</code> 值。</p>
<p>不可以将BigInt和常规数字类型进行计算</p>
<pre><code class="hljs js"><span class="hljs-title function_">alert</span>(<span class="hljs-number">1n</span> + <span class="hljs-number">2</span>); <span class="hljs-comment">// Error: Cannot mix BigInt and other types</span></code></pre>

<p>这也就意味着我们无法对其使用一元加法</p>
<p>注意number和BigInt属于不同类型</p>
<h4 id="3-String类型"><a href="#3-String类型" class="headerlink" title="3. String类型"></a>3. String类型</h4><p>在 JavaScript 中，有三种包含字符串的方式。</p>
<ol>
<li>双引号：<code>&quot;Hello&quot;</code>.</li>
<li>单引号：<code>&#39;Hello&#39;</code>.</li>
<li>反引号：<code>Hello</code>.</li>
</ol>
<p>双引号和单引号都是“简单”引用，在 JavaScript 中两者几乎没有什么差别。</p>
<p>反引号是 <strong>功能扩展</strong> 引号。它们允许我们通过将变量和表达式包装在 <code>$&#123;…&#125;</code> 中，来将它们嵌入到字符串中。</p>
<blockquote>
<p>JavaScript 中没有 character 类型。</p>
</blockquote>
<h4 id="4-布尔类型"><a href="#4-布尔类型" class="headerlink" title="4. 布尔类型"></a>4. 布尔类型</h4><p>在 JavaScript 中，undefined、null、””、0、NaN 和 false 这 6 个特殊值转换为布尔值时为 false，被称为假值。除了假值以外，其他任何类型的数据转换为布尔值时都是 true。</p>
<blockquote>
<p>注意在使用<code>Boolean</code>判断时任何非空字符串都是true包含‘0’</p>
</blockquote>
<h4 id="5-null"><a href="#5-null" class="headerlink" title="5. null"></a>5. null</h4><p>相比较于其他编程语言，JavaScript 中的 <code>null</code> 不是一个“对不存在的 <code>object</code> 的引用”或者 “null 指针”。</p>
<p>JavaScript 中的 <code>null</code> 仅仅是一个代表“无”、“空”或“值未知”的特殊值。</p>
<h4 id="6-undefined"><a href="#6-undefined" class="headerlink" title="6. undefined"></a>6. undefined</h4><p>undefined的含义表示<code>未被赋值</code>，使用typeof判断null返回object，这是官方承认的一个错误，实际上null是一个自己的类型而非object</p>
<blockquote>
<p>建议将null作为一个<code>空或者未知</code>的变量，将undefined作为一个<code>未进行初始化</code>的事物</p>
</blockquote>
<h4 id="7-object和symbol"><a href="#7-object和symbol" class="headerlink" title="7. object和symbol"></a>7. object和symbol</h4><h4 id="8-typeof"><a href="#8-typeof" class="headerlink" title="8. typeof"></a>8. typeof</h4><p><code>typeof</code> 运算符返回参数的类型。</p>
<ol>
<li>作为运算符：<code>typeof x</code>。</li>
<li>函数形式：<code>typeof(x)</code>。</li>
</ol>
<h3 id="2-5-交互"><a href="#2-5-交互" class="headerlink" title="2.5. 交互"></a>2.5. 交互</h3><h5 id="1-alert"><a href="#1-alert" class="headerlink" title="1. alert"></a>1. alert</h5><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello&quot;</span>);</code></pre>

<p>弹出的这个带有信息的小窗口被称为 <strong>模态窗</strong>。“modal” 意味着用户不能与页面的其他部分（例如点击其他按钮等）进行交互，直到他们处理完窗口。</p>
<h5 id="2-prompt"><a href="#2-prompt" class="headerlink" title="2. prompt"></a>2. prompt</h5><pre><code class="hljs javascript"><span class="hljs-comment">// title显示给用户的文本</span>
<span class="hljs-comment">// default可选，指定input的初始值</span>
<span class="hljs-comment">// 返回用户输入的值，为输入得到null</span>
result = <span class="hljs-title function_">prompt</span>(title, [<span class="hljs-keyword">default</span>]);</code></pre>

<p>浏览器会显示一个带有文本消息的模态窗口，还有 input 框和确定/取消按钮。</p>
<h5 id="3-confirm"><a href="#3-confirm" class="headerlink" title="3. confirm"></a>3. confirm</h5><pre><code class="hljs javascript">result = <span class="hljs-title function_">confirm</span>(question);</code></pre>

<p><code>confirm</code> 函数显示一个带有 <code>question</code> 以及确定和取消两个按钮的模态窗口。</p>
<p>点击确定返回 <code>true</code>，点击取消返回 <code>false</code></p>
<p>上述所有方法共有两个限制：</p>
<ol>
<li>模态窗口的确切位置由浏览器决定。通常在页面中心。</li>
<li>窗口的确切外观也取决于浏览器。我们不能修改它。</li>
</ol>
<h3 id="2-6-类型判断"><a href="#2-6-类型判断" class="headerlink" title="2.6. 类型判断"></a>2.6. 类型判断</h3><h4 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1. typeof"></a>1. typeof</h4><h4 id="2-constructor"><a href="#2-constructor" class="headerlink" title="2. constructor"></a>2. constructor</h4><p>constructor 是 Object 类型的原型属性，它能够返回当前对象的构造器（类型函数）。利用该属性，可以检测复合型数据的类型，如对象、数组和函数等。</p>
<p>undefined 和 null 没有 constructor 属性，不能够直接读取，否则会抛出异常。因此，一般应先检测值是否为 undefined 和 null 等特殊值，然后再调用 constructor 属性。</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> value = <span class="hljs-literal">undefined</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value &amp;&amp; value.<span class="hljs-property">constructor</span>);  <span class="hljs-comment">//返回 undefined</span>
<span class="hljs-keyword">var</span> value = <span class="hljs-literal">null</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value &amp;&amp; value.<span class="hljs-property">constructor</span>);  <span class="hljs-comment">//返回 null</span></code></pre>

<p>数值直接量也不能直接读取 constructor 属性，应该先把它转换为对象再调用。</p>
<pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">10.</span>construetor);  <span class="hljs-comment">//抛出异常</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-number">10</span>).<span class="hljs-property">constructor</span>);  <span class="hljs-comment">//返回 Number 类型</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>(<span class="hljs-number">10</span>).<span class="hljs-property">constructor</span>);  <span class="hljs-comment">//返回 Number 类型</span></code></pre>

<h4 id="3-toString"><a href="#3-toString" class="headerlink" title="3. toString"></a>3. toString</h4><p>toString 是 Object 类型的原型方法，它能够返回当前对象的字符串表示。利用该属性，可以检测复合型数据的类型，如对象、数组、函数、正则表达式、错误对象、宿主对象、自定义类型对象等；也可以对值类型数据进行检测。</p>
<blockquote>
<p>toString返回的字符串根据各个对象会有所不同，各个对象可能对该函数进行重写。</p>
<p>使用原型下的toString返回的格式就会统一</p>
</blockquote>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> _toString = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>;  <span class="hljs-comment">//引用 Objget 的原型方法 toString ()</span>
<span class="hljs-comment">//使用 apply 方法在对象上动态调用 Object 的原型方法 toString ()</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(_toString.<span class="hljs-title function_">apply</span>(o));  <span class="hljs-comment">//表示为 &quot;[object Object]&quot;</span></code></pre>

<p>仔细发现我们会发现原型的toString返回的格式如下：</p>
<pre><code class="hljs javascript">[object <span class="hljs-title class_">Class</span>]</code></pre>

<p>其中，object 表示对象的基本类型，Class 表示对象的子类型，子类型的名称与该对象的构造函数名对应。例如，Object 对象的 Class 为 “Object”，Array 对象的 Class 为 “Array” , Function 对象的 Class 为 “Function”, Date 对象的 Class 为 “Date”，Math 对象的 Class 为 “Math”，Error 对象（包括 Error 子类）的 Class 为 “Error” 等。</p>
<h3 id="2-7-类型转换"><a href="#2-7-类型转换" class="headerlink" title="2.7. 类型转换"></a>2.7. 类型转换</h3><h4 id="1-转换为字符串"><a href="#1-转换为字符串" class="headerlink" title="1. 转换为字符串"></a>1. 转换为字符串</h4><h5 id="1-使用加号运算符"><a href="#1-使用加号运算符" class="headerlink" title="1. 使用加号运算符"></a>1. 使用加号运算符</h5><ul>
<li>把数字转换为字符串，返回数字本身。</li>
<li>把布尔值转换为字符串，返回字符串 “true” 或 “false”。</li>
<li>把数组转换为字符串，返回数组元素列表，以逗号分隔。如果是空数组，则返回空字符串。</li>
<li>把函数转换为字符串，返回函数的具体代码字符串。<ul>
<li>如果是内置类型函数，则只返回构造函数的基本结构，省略函数的具体实现代码。而自定义类型函数与普通函数一样，返回函数的具体实现代码字符串。</li>
<li>如果是内置静态函数，则返回 [object Class] 格式的字符串表示。</li>
</ul>
</li>
<li>如果把对象实例转换为字符串，则返回的字符串会根据不同类型或定义对象的方法和参数而不同。<ul>
<li>对象直接量，则返回字符串为 “[object object]”</li>
<li>如果是自定义类的对象实例，则返回字符串为 “[object object]”。</li>
<li>如果是内置对象实例，具体返回字符串将根据参数而定。</li>
</ul>
</li>
</ul>
<blockquote>
<p>加号运算符有两个计算功能：数值求和、字符串连接。但是字符串连接操作的优先级要大于求和运算。因此，在可能的情况下，即运算元的数据类型不一致时，加号运算符会尝试把数值运算元转换为字符串，再执行连接操作。</p>
</blockquote>
<h5 id="2-使用toString"><a href="#2-使用toString" class="headerlink" title="2. 使用toString"></a>2. 使用toString</h5><p>当为简单的值调用 toString() 方法时，JavaScript 会自动把它们封装为对象，然后再调用 toString() 方法，获取对象的字符串表示。</p>
<p>使用加号运算符转换字符串，实际上也是调用 toString() 方法来完成，只不过是 JavaScript 自动调用 toString() 方法实现的。</p>
<p>JavaScript 能够根据运算环境自动转换变量的类型。在自动转换中，JavaScript 一般根据运算的类型环境，按需进行转换。例如，如果在执行字符串为字符串；如果在执行基本数学运算，则会尝试把字符串转换为数值；如果在逻辑运算环境中，则会尝试把值转换为布尔值等。</p>
<h4 id="2-转换为数字模式字符串"><a href="#2-转换为数字模式字符串" class="headerlink" title="2. 转换为数字模式字符串"></a>2. 转换为数字模式字符串</h4><p>toString() 是 Object 类型的原型方法，Number 子类继承该方法后，重写了 toString()，允许传递一个整数参数，设置显示模式。数字默认为十进制显示模式，通过设置参数可以改变数字模式。</p>
<p>toString() 方法能够直接输出整数和浮点数，保留小数位。小数位末尾的零会被清除。但是对于科学计数法，则会在条件许可的情况下把它转换为浮点数，否则就用科学计数法形式输出字符串。</p>
<p>在默认情况下，无论数值采用什么模式表示，toString() 方法返回的都是十进制的数字字符串。因此，对于八进制、二进制或十六进制的数字，toString() 方法都会先把它们转换为十进制数值之后再输出。</p>
<p>如果设置参数，则 toString() 方法会根据参数把数值转换为对应进制的值之后，再输出为字符串表示。</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;  <span class="hljs-comment">//十进制数值 10</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>));  <span class="hljs-comment">//返回二进制数字字符串“1010”</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">toString</span>(<span class="hljs-number">8</span>));  <span class="hljs-comment">//返回八进制数字字符串“12”</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>));  <span class="hljs-comment">//返回十六进制数字字符串“a”</span></code></pre>

<h4 id="3-转换为小数格式字符串"><a href="#3-转换为小数格式字符串" class="headerlink" title="3. 转换为小数格式字符串"></a>3. 转换为小数格式字符串</h4><p>由于toString在小数转换时会抹掉末尾的0，这对某些领域是极为不便的</p>
<h5 id="1-toFixed"><a href="#1-toFixed" class="headerlink" title="1. toFixed()"></a>1. toFixed()</h5><p>toFixed() 能够把数值转换为字符串，并显示小数点后的指定位数。默认为0</p>
<h5 id="2-toExponential"><a href="#2-toExponential" class="headerlink" title="2. toExponential()"></a>2. toExponential()</h5><p>toExponential() 方法专门用来把数字转换为科学计数法形式的字符串，toExponential() 方法的参数指定了保留的<strong>小数位数</strong>。省略部分采用四舍五入的方式进行处理。</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">123456789</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">toExponential</span>(<span class="hljs-number">2</span>));  <span class="hljs-comment">//返回字符串“1.23e+8”</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">toExponential</span>(<span class="hljs-number">4</span>));  <span class="hljs-comment">//返回字符串“1.2346e+8”</span></code></pre>

<h5 id="3-toPrecision"><a href="#3-toPrecision" class="headerlink" title="3. toPrecision()"></a>3. toPrecision()</h5><p>toPrecision() 方法与 toExponential() 方法相似，但它可以指定<strong>有效数字的位数</strong>，而不是指定小数位数。</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">123456789</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">toPrecision</span>(<span class="hljs-number">2</span>));  <span class="hljs-comment">//返回字符串“1.2e+8”</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">toPrecision</span>(<span class="hljs-number">4</span>));  <span class="hljs-comment">//返回字符串“1.235e+8”</span></code></pre>

<h4 id="4-转换为数字"><a href="#4-转换为数字" class="headerlink" title="4. 转换为数字"></a>4. 转换为数字</h4><table>
<thead>
<tr>
<th>1</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>true</td>
<td>1</td>
</tr>
<tr>
<td>false</td>
<td>0</td>
</tr>
<tr>
<td>“”</td>
<td>0</td>
</tr>
<tr>
<td>undefined</td>
<td>NaN</td>
</tr>
<tr>
<td>null</td>
<td>0</td>
</tr>
<tr>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>Infinity</td>
<td>Infinity</td>
</tr>
</tbody></table>
<h5 id="1-parseInt"><a href="#1-parseInt" class="headerlink" title="1. parseInt()"></a>1. parseInt()</h5><p>从左至右依次解析字符串，若遇到非数字则停止，最后结果没有数字就返回NaN</p>
<pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;123abc&quot;</span>));  <span class="hljs-comment">//返回数字123</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;1.73&quot;</span>));   <span class="hljs-comment">//返回数字1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;.123&quot;</span>));   <span class="hljs-comment">//返回值NaN</span></code></pre>

<p>如果是以 0 开头的数字字符串，则 parseInt() 会把它作为八进制数字处理：先把它转换为八进制数值，然后再转换为十进制的数字返回。</p>
<p>如果是以 0x 开头的数字字符串，则 parseInt() 会把它作为十六进制数字处理：先把它转换为十六进制数值，然后再转换为十进制的数字返回。</p>
<blockquote>
<p>parseInt() 也支持基模式(设置数值为指定进制，但是都返回十进制)，可以把二进制、八进制、十六进制等不同进制的数字字符串转换为整数。基模式由 parseInt() 函数的第二个参数指定。</p>
</blockquote>
<h5 id="2-parseFloat"><a href="#2-parseFloat" class="headerlink" title="2. parseFloat()"></a>2. parseFloat()</h5><p>parseFloat() 也是一个全局方法，它可以把值转换为浮点数，即它能够识别第一个出现的小数点，而第二个小数点被视为非法。解析过程与 parseInt() 方法相同。</p>
<p>parseFloat() 的参数必须是十进制形式的字符串，而不能使用八进制或十六进制的数字字符串。同时，对于数字前面的 0（八进制数字标识）会忽略，对于十六进制的数字将返回 0。</p>
<h5 id="3-使用乘号运算符"><a href="#3-使用乘号运算符" class="headerlink" title="3. 使用乘号运算符"></a>3. 使用乘号运算符</h5><p>如果变量乘以 1，则变量会被 JavaScript 自动转换为数值。乘以 1 之后，结果没有发生变化，但是值的类型被转换为数值。如果值无法被缓缓为合法的数值，则返回 NaN。</p>
<h4 id="5-转换为布尔值"><a href="#5-转换为布尔值" class="headerlink" title="5. 转换为布尔值"></a>5. 转换为布尔值</h4><table>
<thead>
<tr>
<th>1</th>
<th>true</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>false</td>
</tr>
<tr>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>“”</td>
<td>false</td>
</tr>
<tr>
<td>undefined</td>
<td>false</td>
</tr>
<tr>
<td>null</td>
<td>false</td>
</tr>
<tr>
<td>NaN</td>
<td>false</td>
</tr>
<tr>
<td>Infinity</td>
<td>true</td>
</tr>
</tbody></table>
<ul>
<li>使用双重逻辑非：！！</li>
<li>使用Boolean()函数</li>
</ul>
<h4 id="6-转换为对象"><a href="#6-转换为对象" class="headerlink" title="6. 转换为对象"></a>6. 转换为对象</h4><p>类似java的包装器</p>
<pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(n));  <span class="hljs-comment">//返回Object</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(n));  <span class="hljs-comment">//返回Object</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(n));  <span class="hljs-comment">//返回Object</span></code></pre>

<h4 id="7-转换为简单值"><a href="#7-转换为简单值" class="headerlink" title="7. 转换为简单值"></a>7. 转换为简单值</h4><p>==//TODO==</p>
<h3 id="2-8-基础运算"><a href="#2-8-基础运算" class="headerlink" title="2.8. 基础运算"></a>2.8. 基础运算</h3><h4 id="1-加法运算"><a href="#1-加法运算" class="headerlink" title="1. 加法运算"></a>1. 加法运算</h4><p>特殊操作数的求和运算</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> n = <span class="hljs-number">5</span>;  <span class="hljs-comment">//定义并初始化任意一个数值</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> + n);  <span class="hljs-comment">//NaN与任意操作数相加，结果都是NaN</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Infinity</span> + n);  <span class="hljs-comment">//Infinity与任意操作数相加，结果都是Infinity</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Infinity</span> + <span class="hljs-title class_">Infinity</span>);  <span class="hljs-comment">//Infinity与Infinity相加，结果是Infinity</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((-<span class="hljs-title class_">Infinity</span>) + (-<span class="hljs-title class_">Infinity</span>));  <span class="hljs-comment">//负Infinity相加，结果是负Infinity</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((-<span class="hljs-title class_">Infinity</span>) + <span class="hljs-title class_">Infinity</span>);  <span class="hljs-comment">//正负Infinity相加，结果是NaN</span></code></pre>

<h4 id="2-减法运算"><a href="#2-减法运算" class="headerlink" title="2. 减法运算"></a>2. 减法运算</h4><p>特殊操作数的减法运算</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> n = <span class="hljs-number">5</span>;  <span class="hljs-comment">//定义并初始化任意一个数值</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> - n);  <span class="hljs-comment">//NaN与任意操作数相减，结果都是NaN</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Infinity</span> - n);  <span class="hljs-comment">//Infinity与任意操作数相减，结果都是Infinity</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Infinity</span> - <span class="hljs-title class_">Infinity</span>);  <span class="hljs-comment">//Infinity与Infinity相减，结果是NaN</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((-<span class="hljs-title class_">Infinity</span>) - (-<span class="hljs-title class_">Infinity</span>));  <span class="hljs-comment">//负Infinity相减，结果是NaN</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((-<span class="hljs-title class_">Infinity</span>) - <span class="hljs-title class_">Infinity</span>);  <span class="hljs-comment">//正负Infinity相减，结果是-Infinity</span></code></pre>

<blockquote>
<p>使用值减去 0，可以快速把值转换为数字。例如 HTTP 请求中查询字符串一般都是字符串型数字，可以先把这些参数值减去 0 转换为数值。这与调用 parseFloat() 方法的结果相同，但减法更高效、快捷。减法运算符的隐性转换如果失败，则返回 NaN，这与使用 parseFloat() 方法执行转换时的返回值是不同的。</p>
</blockquote>
<p>对于字符串减法必须是完整的数字字符串否则会返回NaN</p>
<p>对于布尔值来说，parseFloat() 方法能够把 true 转换为 1，把 false 转换为 0，而减法运算符视其为 NaN。</p>
<p>对于对象来说，parseFloat() 方法会尝试调用对象的 toString() 方法进行转换，而减法运算符先尝试调用对象的 valueOf() 方法进行转换，失败之后再调用 toString() 进行转换。</p>
<h4 id="3-乘法运算"><a href="#3-乘法运算" class="headerlink" title="3. 乘法运算"></a>3. 乘法运算</h4><p>特殊操作数的乘法运算</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> n = <span class="hljs-number">5</span>;  <span class="hljs-comment">//定义并初始化任意一个数值</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> * n);  <span class="hljs-comment">//NaN与任意操作数相乘，结果都是NaN</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Infinity</span> * n);  <span class="hljs-comment">//Infinity与任意非零正数相乘，结果都是Infinity</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Infinity</span> * (- n));  <span class="hljs-comment">//Infinity与任意非零负数相乘，结果是-Infinity</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Infinity</span> * <span class="hljs-number">0</span>);  <span class="hljs-comment">//Infinity与0相乘，结果是NaN</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Infinity</span> * <span class="hljs-title class_">Infinity</span>);  <span class="hljs-comment">//Infinity与Infinity相乘，结果是Infinity</span></code></pre>

<h4 id="4-除法运算"><a href="#4-除法运算" class="headerlink" title="4. 除法运算"></a>4. 除法运算</h4><p>特殊操作数的除法运算</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span>  n = <span class="hljs-number">5</span>;  <span class="hljs-comment">//定义并初始化任意一个数值</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> / n);  <span class="hljs-comment">//如果一个操作数是NaN，结果都是NaN</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Infinity</span> / n);  <span class="hljs-comment">//Infinity被任意数字除，结果是Infinity或-Infinity</span>
                            <span class="hljs-comment">//符号由第二个操作数的符号决定</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Infinity</span> / <span class="hljs-title class_">Infinity</span>);  <span class="hljs-comment">//返回NaN</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n / <span class="hljs-number">0</span>);  <span class="hljs-comment">//0除一个非无穷大的数字，结果是Infinity或-Infinity，符号由第二个操作数的符号决定</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n / -<span class="hljs-number">0</span>);  <span class="hljs-comment">//返回-Infinity，解释同上</span></code></pre>

<h4 id="5-求余运算"><a href="#5-求余运算" class="headerlink" title="5. 求余运算"></a>5. 求余运算</h4><h4 id="6-取反运算"><a href="#6-取反运算" class="headerlink" title="6. 取反运算"></a>6. 取反运算</h4><p>特殊操作数的取反运算</p>
<pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(- <span class="hljs-number">5</span>);  <span class="hljs-comment">//返回-5。正常数值取负数</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(- <span class="hljs-string">&quot;5&quot;</span>);  <span class="hljs-comment">//返回-5。先转换字符串数字为数值类型</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(- <span class="hljs-string">&quot;a&quot;</span>);  <span class="hljs-comment">//返回NaN。无法完全匹配运算，返回NaN</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(- <span class="hljs-title class_">Infinity</span>);  <span class="hljs-comment">//返回-Infinity</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(- (- <span class="hljs-title class_">Infinity</span>));  <span class="hljs-comment">//返回Infinity</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(- <span class="hljs-title class_">NaN</span>);  <span class="hljs-comment">//返回NaN</span></code></pre>

<h4 id="7-递增递减运算"><a href="#7-递增递减运算" class="headerlink" title="7. 递增递减运算"></a>7. 递增递减运算</h4><p>递增和递减是相反的操作，在运算之前都会试图转换值为数值类型，如果失败则返回 NaN。</p>
<h4 id="8-链式赋值"><a href="#8-链式赋值" class="headerlink" title="8. 链式赋值"></a>8. 链式赋值</h4><pre><code class="hljs js"><span class="hljs-keyword">let</span> a, b, c;
a = b = c = <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;</code></pre>

<h4 id="9-逗号运算符"><a href="#9-逗号运算符" class="headerlink" title="9. 逗号运算符"></a>9. 逗号运算符</h4><p>逗号运算符能让我们处理多个语句，使用 <code>,</code> 将它们分开。每个语句都运行了，但是只有<code>最后的语句的结果</code>会被返回。</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> a = (<span class="hljs-number">1</span> + <span class="hljs-number">2</span>, <span class="hljs-number">3</span> + <span class="hljs-number">4</span>);

<span class="hljs-title function_">alert</span>( a ); <span class="hljs-comment">// 7（3 + 4 的结果）</span></code></pre>

<h4 id="10-大小比较"><a href="#10-大小比较" class="headerlink" title="10. 大小比较"></a>10. 大小比较</h4><p>比较运算中的操作数可以是任意类型的值，但是在执行大小运算时，会被<code>转换为数字或字符串</code>，然后再进行比较。如果是数字，则比较大小；如果是字符串，则根据字符编码表中的编号值从左到右逐个比较每个字符。</p>
<p>如果一个操作数是数字，或者被转换为数字，另一个是字符串，或者被转换为字符串，则使用 parseInt() 将字符串转换为数字（对于非数字字符串，将被转换为 NaN），最后以数字方式进行比较。</p>
<p>如果一个操作数为<code> NaN</code>，或者被转换为 NaN，则始终返回 <code>false</code>。</p>
<p>如果一个操作数是<code>对象</code>，则先使用 <code>valueOf()</code> 取其值，再进行比较；如果没有 valueOf() 方法，则使用<code> toString()</code> 取其字符串表示，再进行比较。</p>
<p>如果一个操作数是<code>布尔值</code>，则先转换为<code>数值</code>，再进行比较。</p>
<p>如果操作数都<code>无法转换为数字或字符串</code>，则比较结果为 <code>false</code>。</p>
<blockquote>
<p>字符比较是区分大小写的，一般小写字符大于大写字符。如果不区分大小写，则建议使用 toLowerCase() 或 toUpperCase() 方法把字符串统一为小写或大写形式之后再比较。</p>
</blockquote>
<p>==为了设计可控的比较运算，建议先检测操作数的类型，主动转换类型。==</p>
<p>==奇怪的结果：==</p>
<pre><code class="hljs js"><span class="hljs-title function_">alert</span>( <span class="hljs-literal">null</span> &gt; <span class="hljs-number">0</span> );  <span class="hljs-comment">// (1) false</span>
<span class="hljs-title function_">alert</span>( <span class="hljs-literal">null</span> == <span class="hljs-number">0</span> ); <span class="hljs-comment">// (2) false</span>
<span class="hljs-title function_">alert</span>( <span class="hljs-literal">null</span> &gt;= <span class="hljs-number">0</span> ); <span class="hljs-comment">// (3) true</span></code></pre>

<p>这是因为在执行<code>==</code>检查和<code>&gt;&lt;&gt;=&lt;=</code>检查的处理逻辑并不相同。</p>
<p><code>undefined</code> 和 <code>null</code> 在相等性检查 <code>==</code> 中不会进行任何的类型转换，它们有自己独立的比较规则，所以除了<code>它们之间互等</code>外，不会等于任何其他的值。</p>
<p>==特殊的undefined==</p>
<pre><code class="hljs js"><span class="hljs-title function_">alert</span>( <span class="hljs-literal">undefined</span> &gt; <span class="hljs-number">0</span> ); <span class="hljs-comment">// false (1)</span>
<span class="hljs-title function_">alert</span>( <span class="hljs-literal">undefined</span> &lt; <span class="hljs-number">0</span> ); <span class="hljs-comment">// false (2)</span>
<span class="hljs-title function_">alert</span>( <span class="hljs-literal">undefined</span> == <span class="hljs-number">0</span> ); <span class="hljs-comment">// false (3)</span></code></pre>

<blockquote>
<p>总结<code>undefined</code> 和 <code>null</code>在与其它内容<code>==</code>判断下会转换为NaN，如果两者相互判断则相等。</p>
</blockquote>
<h3 id="2-9-‘-’和’-’"><a href="#2-9-‘-’和’-’" class="headerlink" title="2.9 ‘??’和’||’"></a>2.9 ‘??’和’||’</h3><h4 id="1-空值合并运算符‘-’"><a href="#1-空值合并运算符‘-’" class="headerlink" title="1. 空值合并运算符‘??’"></a>1. 空值合并运算符‘??’</h4><p><code>a ?? b</code> 的结果是：</p>
<ul>
<li>如果 <code>a</code> 是已定义的，则结果为 <code>a</code>，</li>
<li>如果 <code>a</code> 不是已定义的，则结果为 <code>b</code>。</li>
</ul>
<blockquote>
<p>这里的已定义是指非undefined和null</p>
</blockquote>
<p>它与<code>||</code>和<code>&amp;&amp;</code>区别就是：</p>
<ul>
<li><code>||</code> 返回第一个 <strong>真</strong> 值。</li>
<li><code>??</code> 返回第一个 <strong>已定义的</strong> 值。</li>
<li><code>&amp;&amp;</code>返回第一个<strong>假</strong>值</li>
</ul>
<blockquote>
<p>这三种运算符可以连续使用，但出于安全原因，JavaScript 禁止将 <code>??</code> 运算符与 <code>&amp;&amp;</code> 和 <code>||</code> 运算符一起使用，除非使用括号明确指定了优先级。这三种运算符都属于<code>短路运算符</code></p>
</blockquote>
<h3 id="2-10-函数"><a href="#2-10-函数" class="headerlink" title="2.10. 函数"></a>2.10. 函数</h3><p>一个函数是一个行为，所以函数名通常是动词。</p>
<p>目前有许多优秀的函数名前缀，如 <code>create…</code>、<code>show…</code>、<code>get…</code>、<code>check…</code> 等等。使用它们来提示函数的作用吧。</p>
<h4 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h4><p><code>函数对外部变量拥有全部的访问权限，如果在函数内部声明了同名变量，那么函数会遮蔽外部变量。</code></p>
<h4 id="2-参数"><a href="#2-参数" class="headerlink" title="2. 参数"></a>2. 参数</h4><p>如果未提供参数，那么其默认值则是 <code>undefined</code>。</p>
<pre><code class="hljs js"><span class="hljs-comment">// 第二个参数有默认值</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">showMessage</span>(<span class="hljs-params"><span class="hljs-keyword">from</span>, text = <span class="hljs-string">&quot;no text given&quot;</span></span>) &#123;
  <span class="hljs-title function_">alert</span>( <span class="hljs-keyword">from</span> + <span class="hljs-string">&quot;: &quot;</span> + text );
&#125;</code></pre>

<p>作为参数传递给函数的值，会被复制到函数的局部变量。</p>
<h4 id="3-返回值"><a href="#3-返回值" class="headerlink" title="3. 返回值"></a>3. 返回值</h4><p><strong>空值的</strong> <code>return</code> <strong>或没有</strong> <code>return</code> <strong>的函数返回值为</strong> <code>undefined</code></p>
<p>空值的 <code>return</code> 和 <code>return undefined</code> 等效：</p>
<blockquote>
<p><strong>不要在</strong> <code>return</code> <strong>与返回值之间添加新行</strong>。因为 JavaScript 默认会在 <code>return</code> 之后加上分号</p>
</blockquote>
<pre><code class="hljs js"><span class="hljs-keyword">return</span>  <span class="hljs-comment">// 会在后面默认加一个”;“</span>
 (some + long + expression + or + whatever * <span class="hljs-title function_">f</span>(a) + <span class="hljs-title function_">f</span>(b))</code></pre>

<h4 id="4-函数表达式"><a href="#4-函数表达式" class="headerlink" title="4. 函数表达式"></a>4. 函数表达式</h4><pre><code class="hljs js"><span class="hljs-comment">// 函数声明</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Hello&quot;</span> );
&#125;
<span class="hljs-comment">// 函数表达式，所以末尾有一个分号</span>
<span class="hljs-keyword">let</span> sayHi = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Hello&quot;</span> );
&#125;;
<span class="hljs-comment">// 将函数本身赋值到a中</span>
<span class="hljs-keyword">let</span> a=sayHi;
<span class="hljs-comment">// 可以正常像sayHi()一样调用</span>
<span class="hljs-title function_">a</span>();

<span class="hljs-comment">// 将函数的值赋值给b</span>
<span class="hljs-keyword">let</span> b=<span class="hljs-title function_">sayHi</span>();
</code></pre>

<blockquote>
<p>严格模式下，当一个函数声明在一个代码块内时，它在该代码块内的<code>任何位置</code>都是可见的。但在代码块外不可见。</p>
</blockquote>
<h4 id="5-回调函数"><a href="#5-回调函数" class="headerlink" title="5. 回调函数"></a>5. 回调函数</h4><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ask</span>(<span class="hljs-params">question, yes, no</span>) &#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">confirm</span>(question)) <span class="hljs-title function_">yes</span>()
    <span class="hljs-keyword">else</span> <span class="hljs-title function_">no</span>();
&#125;</code></pre>

<p>ask传入yes和no两个回调函数，如果question为真，则调用yes，反之调用no</p>
<h4 id="6-箭头函数"><a href="#6-箭头函数" class="headerlink" title="6. 箭头函数"></a>6. 箭头函数</h4><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params">arg1, arg2, ...argN</span>) =&gt; expression
<span class="hljs-comment">// 等同于下面的表达式</span>
<span class="hljs-keyword">let</span> func = <span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2, ...argN</span>) &#123;
    <span class="hljs-keyword">return</span> expression;
&#125;;

<span class="hljs-comment">// 多行箭头函数，需要return</span>
<span class="hljs-keyword">let</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params">arg1, arg2, ...argN</span>) =&gt; &#123;
    <span class="hljs-keyword">return</span> expression
&#125;</code></pre>

<blockquote>
<p>普通函数中，是包含this的，只是可能this的指向为undefined，而在箭头函数中，它没有this，如果缺少它会像变量一样在外部的词法环境中查找。</p>
</blockquote>
<blockquote>
<p>不具有 <code>this</code> 自然也就意味着另一个限制：箭头函数不能用作构造器（constructor）。不能用 <code>new</code> 调用它们。</p>
</blockquote>
<blockquote>
<p>箭头函数没有 <code>arguments</code> 对象。</p>
</blockquote>
<blockquote>
<p>箭头函数没有 <code>super</code> </p>
</blockquote>
<h2 id="3-Object-对象-：基础知识"><a href="#3-Object-对象-：基础知识" class="headerlink" title="3. Object(对象)：基础知识"></a>3. Object(对象)：基础知识</h2><h3 id="3-1-对象"><a href="#3-1-对象" class="headerlink" title="3.1. 对象"></a>3.1. 对象</h3><h4 id="1-对象创建"><a href="#1-对象创建" class="headerlink" title="1. 对象创建"></a>1. 对象创建</h4><pre><code class="hljs js"><span class="hljs-comment">// “构造函数” 的语法</span>
<span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();

<span class="hljs-comment">// “字面量” 的语法</span>
<span class="hljs-keyword">let</span> user = &#123;
    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,
    <span class="hljs-string">&quot;likes birds&quot;</span>: <span class="hljs-literal">true</span> ,  <span class="hljs-comment">// 最后一个属性建议用逗号结尾（尾随、悬挂逗号） </span>
&#125;; 
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user[<span class="hljs-string">&quot;likes birds&quot;</span>]); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">name</span>); <span class="hljs-comment">//John</span></code></pre>

<h4 id="2-属性删除"><a href="#2-属性删除" class="headerlink" title="2. 属性删除"></a>2. 属性删除</h4><pre><code class="hljs js"><span class="hljs-keyword">delete</span> user.<span class="hljs-property">age</span>;</code></pre>

<h4 id="3-属性修改"><a href="#3-属性修改" class="headerlink" title="3. 属性修改"></a>3. 属性修改</h4><blockquote>
<p>使用 <code>const</code> 声明的对象是可以被修改的，<code>const</code> 声明仅固定了 <code>user</code> 的值，而不是值（该对象）里面的内容。</p>
</blockquote>
<h4 id="4-计算属性"><a href="#4-计算属性" class="headerlink" title="4. 计算属性"></a>4. 计算属性</h4><pre><code class="hljs js"><span class="hljs-keyword">let</span> fruit = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;Which fruit to buy?&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>);

<span class="hljs-keyword">let</span> bag = &#123;
    [fruit]: <span class="hljs-number">5</span>, <span class="hljs-comment">// 属性名是从 fruit 变量中得到的</span>
&#125;;

<span class="hljs-title function_">alert</span>( bag.<span class="hljs-property">apple</span> ); <span class="hljs-comment">// 5 如果 fruit=&quot;apple&quot;</span></code></pre>

<blockquote>
<p>属性名称可以与系统保留字重复，并且任何非字符串类型作为对象键时都会转换为字符串</p>
</blockquote>
<h4 id="5-属性存在：in"><a href="#5-属性存在：in" class="headerlink" title="5. 属性存在：in"></a>5. 属性存在：in</h4><pre><code class="hljs js"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;;

<span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;age&quot;</span> <span class="hljs-keyword">in</span> user ); <span class="hljs-comment">// true，user.age 存在</span></code></pre>

<p>除了<code>in</code>关键字外还可以使用<code>undefined</code>判断，但是它有一定的局限性，比如该属性的值本身就是<code>undefined</code></p>
<h4 id="6-属性遍历：for-in"><a href="#6-属性遍历：for-in" class="headerlink" title="6. 属性遍历：for in"></a>6. 属性遍历：for in</h4><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user) &#123;
  <span class="hljs-comment">// keys</span>
  <span class="hljs-title function_">alert</span>( key );  <span class="hljs-comment">// name, age, isAdmin</span>
  <span class="hljs-comment">// 属性键的值</span>
  <span class="hljs-title function_">alert</span>( user[key] ); <span class="hljs-comment">// John, 30, true</span>
&#125;</code></pre>

<h3 id="3-2-对象引用和复制"><a href="#3-2-对象引用和复制" class="headerlink" title="3.2. 对象引用和复制"></a>3.2. 对象引用和复制</h3><h4 id="1-对象比较"><a href="#1-对象比较" class="headerlink" title="1. 对象比较"></a>1. 对象比较</h4><p>只有当两个对象的引用指向同一个内存区域才会相等</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> a = &#123;&#125;;
<span class="hljs-keyword">let</span> b = &#123;&#125;; <span class="hljs-comment">// 两个独立的对象</span>

<span class="hljs-title function_">alert</span>( a == b ); <span class="hljs-comment">// false</span></code></pre>

<h4 id="2-克隆与合并：Object-assign"><a href="#2-克隆与合并：Object-assign" class="headerlink" title="2. 克隆与合并：Object.assign"></a>2. 克隆与合并：Object.assign</h4><p>由于直接复制只是复制引用而非对象，可以使用<code>迭代</code>来将属性挨个复制到新对象中。或者使用Object.assign快速克隆：</p>
<pre><code class="hljs js"><span class="hljs-comment">// 将src1、src2...的属性复制到dest对象中，若有相同的属性则会进行内容的覆盖</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(dest, [src1, src2, src3...])</code></pre>

<blockquote>
<p>Object.assign只能浅克隆，可以使用 JavaScript 库 <a href="https://lodash.com/">lodash</a> 中的 <a href="https://lodash.com/docs#cloneDeep">_.cloneDeep(obj)</a>完成深克隆</p>
</blockquote>
<h3 id="3-3-this"><a href="#3-3-this" class="headerlink" title="3.3. this"></a>3.3. this</h3><p>在 JavaScript 中，<code>this</code> 关键字与其他大多数编程语言中的不同。JavaScript 中的 <code>this</code> 可以用于任何函数，即使它不是对象的方法。例如：</p>
<pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-title function_">alert</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> );
&#125;

<span class="hljs-comment">// 若sayHi没有分配给任意对象，则在严格模式下指向undefined，普通模式下指向全局对象(window)</span></code></pre>

<blockquote>
<p><code>this</code> 的值是在代码运行时计算出来的，它取决于代码上下文。</p>
</blockquote>
<blockquote>
<p>箭头函数没有自己的<code>this</code>，它取决于<code>外部正常的函数</code></p>
</blockquote>
<h3 id="3-4-构造器和操作符“new”"><a href="#3-4-构造器和操作符“new”" class="headerlink" title="3.4. 构造器和操作符“new”"></a>3.4. 构造器和操作符“new”</h3><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">false</span>;
&#125;

<span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Jack&quot;</span>);

<span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>); <span class="hljs-comment">// Jack</span>
<span class="hljs-title function_">alert</span>(user.<span class="hljs-property">isAdmin</span>); <span class="hljs-comment">// false</span></code></pre>

<blockquote>
<p>若没有参数可以省略括号，建议不要使用</p>
</blockquote>
<blockquote>
<p>一般情况下构造函数没有<code>return</code>，如果有若返回普通类型则忽略，返回对象则构造出来的对象即为返回的对象。</p>
</blockquote>
<h3 id="3-5-可选链“-”"><a href="#3-5-可选链“-”" class="headerlink" title="3.5. 可选链“?.”"></a>3.5. 可选链“?.”</h3><p>如果可选链 <code>?.</code> 前面的部分是 <code>undefined</code> 或者 <code>null</code>，它会停止运算并返回该部分。</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> user = &#123;&#125;; <span class="hljs-comment">// user 没有 address 属性</span>

<span class="hljs-title function_">alert</span>( user?.<span class="hljs-property">address</span>?.<span class="hljs-property">street</span> ); <span class="hljs-comment">// undefined（不报错）</span></code></pre>

<blockquote>
<p><code>?.</code>最开始的变量必须已声明，否则会触发错误</p>
</blockquote>
<blockquote>
<p><code>?.()</code>调用一个可能不存在的函数，<code>?.[]</code>调用类中可能不存在的属性，可以和<code>delete</code>配合使用删除一个可能不存在的属性</p>
</blockquote>
<h3 id="3-6-Symbol"><a href="#3-6-Symbol" class="headerlink" title="3.6. Symbol"></a>3.6. Symbol</h3><p><code>Symbol</code> 是唯一标识符的基本类型，Symbol 保证是唯一的。即使我们创建了许多具有相同描述的 Symbol，它们的值也是不同。描述只是一个标签，不影响任何东西。</p>
<pre><code class="hljs js"><span class="hljs-comment">// id1的描述为id</span>
<span class="hljs-keyword">let</span> id1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);
<span class="hljs-keyword">let</span> id2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);

<span class="hljs-title function_">alert</span>(id1 == id2); <span class="hljs-comment">// false</span></code></pre>

<blockquote>
<p>Symbol不会被自动转换为字符串，可以通过<code>toString</code>或者<code>description</code>来获取描述</p>
</blockquote>
<blockquote>
<p>可以使用 Symbol 作为键来访问或计算属性类中数据<code>user[id]</code>，作为类中的键会被隐藏属性，无法通过for in迭代出来，只能通过<code>[]</code>访问，但这并不觉得js提供了相关方法来进行Symbol访问迭代</p>
</blockquote>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;age&#x27;</span>)

user = &#123;
    <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;john&#x27;</span>,
    [a]: <span class="hljs-string">&#x27;18&#x27;</span>,
&#125;
<span class="hljs-comment">// 无法使用user[age]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user[a])</code></pre>

<p><strong>全局Symbol注册表</strong></p>
<pre><code class="hljs js"><span class="hljs-comment">// 从全局注册表中读取</span>
<span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;id&quot;</span>); <span class="hljs-comment">// 如果该 Symbol 不存在，则创建它</span>

<span class="hljs-comment">// 再次读取（可能是在代码中的另一个位置）</span>
<span class="hljs-keyword">let</span> idAgain = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;id&quot;</span>);

<span class="hljs-comment">// 相同的 Symbol</span>
<span class="hljs-title function_">alert</span>( id === idAgain ); <span class="hljs-comment">// true</span></code></pre>

<p><strong>Symbol.keyFor：</strong>通过Symbol来反向获取它的描述，<code>只适合用于全局Symbol，非全局会返回undefined</code></p>
<pre><code class="hljs js"><span class="hljs-comment">// 通过 name 获取 Symbol</span>
<span class="hljs-keyword">let</span> sym = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;name&quot;</span>);
<span class="hljs-keyword">let</span> sym2 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;id&quot;</span>);

<span class="hljs-comment">// 通过 Symbol 获取 name</span>
<span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(sym) ); <span class="hljs-comment">// name</span>
<span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(sym2) ); <span class="hljs-comment">// id</span></code></pre>

<h3 id="3-7-对象–原始值转换"><a href="#3-7-对象–原始值转换" class="headerlink" title="3.7 对象–原始值转换"></a>3.7 对象–原始值转换</h3><ul>
<li>所有的对象在布尔上下文（context）中均为 <code>true</code>。</li>
<li>数值转换发生在对象相减或应用数学函数时，如两个<code>Date对象</code>的加减。</li>
<li>字符串的转换</li>
</ul>
<h2 id="4-数据类型"><a href="#4-数据类型" class="headerlink" title="4. 数据类型"></a>4. 数据类型</h2><h3 id="4-1-原始类型"><a href="#4-1-原始类型" class="headerlink" title="4.1. 原始类型"></a>4.1. 原始类型</h3><blockquote>
<p>原始类型是一种值，不同于对象。</p>
</blockquote>
<blockquote>
<p>在 JavaScript 中有 7 种原始类型：<code>string</code>，<code>number</code>，<code>bigint</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code> 和 <code>undefined</code>。</p>
</blockquote>
<blockquote>
<p>一些原始对象有与之对应的<code>包装器类型</code>，它们与之对应的构造器仅供内部使用，不建议使用构造器创建对象（new），利用非new创建却是完全有效的。</p>
</blockquote>
<blockquote>
<p>null/undefined 没有任何方法</p>
</blockquote>
<h3 id="4-2-数字类型"><a href="#4-2-数字类型" class="headerlink" title="4.2. 数字类型"></a>4.2. 数字类型</h3><h4 id="1-科学计数"><a href="#1-科学计数" class="headerlink" title="1. 科学计数"></a>1. 科学计数</h4><pre><code class="hljs js"><span class="hljs-number">1.23e6</span> = <span class="hljs-number">1.23</span> * <span class="hljs-number">1000000</span>
<span class="hljs-number">1e-6</span> = <span class="hljs-number">0.000001</span></code></pre>

<h4 id="2-数字调用函数"><a href="#2-数字调用函数" class="headerlink" title="2. 数字调用函数"></a>2. 数字调用函数</h4><pre><code class="hljs js"><span class="hljs-number">123456.</span>.<span class="hljs-title function_">toString</span>(<span class="hljs-number">36</span>)  <span class="hljs-comment">// 将数字123456按照36进制输出</span></code></pre>

<h4 id="3-舍入"><a href="#3-舍入" class="headerlink" title="3. 舍入"></a>3. 舍入</h4><ul>
<li>Math.floor：向下舍入</li>
<li>Math.ceil：向上舍入</li>
<li>Math.round：向最近的整数舍入</li>
<li>Math.trunc（IE不支持）：小数点后直接截断</li>
</ul>
<h4 id="4-小数格式化"><a href="#4-小数格式化" class="headerlink" title="4. 小数格式化"></a>4. 小数格式化</h4><p><code>toFixed(num)</code>：仅保存到小数点后num位，超出长度填零，少于长度则按照Math.round的方式舍入，返回的是<code>字符串</code>。</p>
<h4 id="5-Object-is"><a href="#5-Object-is" class="headerlink" title="5. Object.is"></a>5. Object.is</h4><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property">is</span>（<span class="hljs-title class_">NaN</span>，<span class="hljs-title class_">NaN</span>）=== <span class="hljs-literal">true</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-property">is</span>（<span class="hljs-number">0</span>，-<span class="hljs-number">0</span>）=== <span class="hljs-literal">false</span>
<span class="hljs-comment">// 在所有其他情况下，Object.is(a，b) 与 a === b 相同。</span></code></pre>

<h4 id="5-parseInt和parseFloat"><a href="#5-parseInt和parseFloat" class="headerlink" title="5. parseInt和parseFloat"></a>5. parseInt和parseFloat</h4><p>它们可以从字符串中“读取”数字，直到无法读取为止。</p>
<pre><code class="hljs js"><span class="hljs-title function_">alert</span>( <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;12.5em&#x27;</span>) ); <span class="hljs-comment">// 12.5</span>
<span class="hljs-title function_">alert</span>( <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;12.3.4&#x27;</span>) ); <span class="hljs-comment">// 12.3，在第二个点出停止了读取</span>
<span class="hljs-title function_">alert</span>( <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;a123&#x27;</span>) ); <span class="hljs-comment">// NaN，第一个符号停止了读取</span></code></pre>

<blockquote>
<p>parseInt的第二个参数指定了按照什么进制解析</p>
</blockquote>
<h4 id="6-其它数学函数"><a href="#6-其它数学函数" class="headerlink" title="6. 其它数学函数"></a>6. 其它数学函数</h4><ul>
<li><code>Math.random()</code>：返回一个从 0 到 1 的随机数（不包括 1）</li>
<li><code>Math.max(a,b,c...)/Math.min(a, b, c...)</code>：从任意数量的参数中返回最大/最小值。</li>
<li><code>Math.pow(n, power)</code>：返回 n 的给定（power）次幂</li>
</ul>
<h3 id="4-3-字符串"><a href="#4-3-字符串" class="headerlink" title="4.3. 字符串"></a>4.3. 字符串</h3><h4 id="1-字符串长度"><a href="#1-字符串长度" class="headerlink" title="1. 字符串长度"></a>1. 字符串长度</h4><blockquote>
<p><code>length属性</code>表示字符串长度，注意不是<code>length函数</code></p>
</blockquote>
<pre><code class="hljs js"><span class="hljs-comment">// &quot;\n&quot;长度为1</span>
<span class="hljs-title function_">alert</span>( <span class="hljs-string">`My\n`</span>.<span class="hljs-property">length</span> ); <span class="hljs-comment">// 3</span></code></pre>

<h4 id="2-字符串访问"><a href="#2-字符串访问" class="headerlink" title="2. 字符串访问"></a>2. 字符串访问</h4><ul>
<li><code>[]</code>访问</li>
<li><code>charAt()</code>访问</li>
<li><code>for..of</code>访问</li>
</ul>
<blockquote>
<p><code>[]</code>没找到返回<code>undefined</code>，<code>charAt</code>没找到返回<code>空字符串</code></p>
</blockquote>
<blockquote>
<p>字符串是不可改变的！<code>toUpperCase/toLowerCase</code>返回的是一个新的字符串</p>
</blockquote>
<h4 id="3-查找字符串"><a href="#3-查找字符串" class="headerlink" title="3. 查找字符串"></a>3. 查找字符串</h4><p><strong>str.indexOf</strong></p>
<p>如果没有找到，则返回 <code>-1</code>，否则返回匹配成功的位置，第二个参数可以指定查找起始位置。</p>
<p><strong>str.lastIndexOf(substr, pos)</strong></p>
<p>与str.indexOf类似，但是这是从后至前查找。</p>
<h4 id="4-按位（bitwise）NOT-技巧"><a href="#4-按位（bitwise）NOT-技巧" class="headerlink" title="4. 按位（bitwise）NOT 技巧"></a>4. 按位（bitwise）NOT 技巧</h4><p>对于 32-bit 整数，<code>~n</code> 等于 <code>-(n+1)</code>。则有n=-1时，得到的结果才会为0</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;Widget&quot;</span>;

<span class="hljs-keyword">if</span> (~str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;Widget&quot;</span>)) &#123;
  <span class="hljs-title function_">alert</span>( <span class="hljs-string">&#x27;Found it!&#x27;</span> ); <span class="hljs-comment">// 正常运行</span>
&#125;</code></pre>

<blockquote>
<p>只有旧代码才会发现那些内容，现在都提供了相关的方法</p>
</blockquote>
<h4 id="5-includes，startsWith，endsWith"><a href="#5-includes，startsWith，endsWith" class="headerlink" title="5. includes，startsWith，endsWith"></a>5. includes，startsWith，endsWith</h4><pre><code class="hljs js"><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Widget with id&quot;</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;Widget&quot;</span>) ); <span class="hljs-comment">// true</span>
<span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Midget&quot;</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">3</span>) ); <span class="hljs-comment">// false, 从位置 3 开始没有 &quot;id&quot;</span>
<span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Widget&quot;</span>.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&quot;Wid&quot;</span>) ); <span class="hljs-comment">// true，&quot;Widget&quot; 以 &quot;Wid&quot; 开始</span>
<span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Widget&quot;</span>.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&quot;get&quot;</span>) ); <span class="hljs-comment">// true，&quot;Widget&quot; 以 &quot;get&quot; 结束</span></code></pre>

<h4 id="6-获取子字符串"><a href="#6-获取子字符串" class="headerlink" title="6. 获取子字符串"></a>6. 获取子字符串</h4><p><strong>str.slice(start [, end])</strong></p>
<p>返回字符串从 <code>start</code> 到（但不包括）<code>end</code> 的部分，如果没有第二个参数，<code>slice</code> 会一直运行到字符串末尾。</p>
<blockquote>
<p>start和end可以是负值</p>
</blockquote>
<p><strong>str.substring(start [, end])</strong></p>
<p>这与 <code>slice</code> 几乎相同，但它允许 <code>start</code> 大于 <code>end</code>。不支持负参数（不像 slice），它们被视为 <code>0</code>。</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;stringify&quot;</span>;
<span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">6</span>, <span class="hljs-number">2</span>) ); <span class="hljs-comment">// &quot;ring&quot;</span></code></pre>

<p><strong>str.substr(start [, length])</strong></p>
<p>与以前的方法相比，这个允许我们指定 <code>length</code> 而不是结束位置。</p>
<h3 id="4-4-数组"><a href="#4-4-数组" class="headerlink" title="4.4. 数组"></a>4.4. 数组</h3><h4 id="1-作用于数组末端的方法"><a href="#1-作用于数组末端的方法" class="headerlink" title="1. 作用于数组末端的方法"></a>1. 作用于数组末端的方法</h4><p><code>pop</code>取出并返回数组的最后一个元素</p>
<p><code>push</code>在数组末端添加元素</p>
<h4 id="2-作用于数组首端的方法"><a href="#2-作用于数组首端的方法" class="headerlink" title="2. 作用于数组首端的方法"></a>2. 作用于数组首端的方法</h4><p><code>shift</code>取出数组的第一个元素并返回它</p>
<p><code>unshift</code>在数组的首端添加元素</p>
<p>数组误用的几种方式:</p>
<ul>
<li>添加一个非数字的属性，比如 <code>arr.test = 5</code>。</li>
<li>制造空洞，比如：添加 <code>arr[0]</code>，然后添加 <code>arr[1000]</code> (它们中间什么都没有)。</li>
<li>以倒序填充数组，比如 <code>arr[1000]</code>，<code>arr[999]</code> 等等。</li>
</ul>
<blockquote>
<p>以上的使用都会让其关闭内部的数组优化</p>
</blockquote>
<p><strong>for in</strong>与<strong>for of</strong>：</p>
<ul>
<li>for in会迭代所有属性，适用于普通对象，除了数组</li>
<li>for of适合数组迭代</li>
</ul>
<h4 id="3-清空数组"><a href="#3-清空数组" class="headerlink" title="3. 清空数组"></a>3. 清空数组</h4><pre><code class="hljs js">arr.<span class="hljs-property">length</span> = <span class="hljs-number">0</span></code></pre>

<h4 id="4-多维数组"><a href="#4-多维数组" class="headerlink" title="4. 多维数组"></a>4. 多维数组</h4><pre><code class="hljs js"><span class="hljs-keyword">let</span> matrix = [
  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],
  [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>],
  [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]
];</code></pre>

<h4 id="5-toString"><a href="#5-toString" class="headerlink" title="5. toString"></a>5. toString</h4><p>数组元素以“<code>,</code>”进行分割</p>
<pre><code class="hljs js"><span class="hljs-title function_">alert</span>( [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] + <span class="hljs-number">1</span> ); <span class="hljs-comment">// &quot;1,21&quot;</span></code></pre>

<h4 id="6-splice"><a href="#6-splice" class="headerlink" title="6. splice"></a>6. splice</h4><p>由于数组属于对象，所以也可以使用<code>delete</code>关键字，但是数组长度并不会变，这个位置的值变成了<code>undefined</code></p>
<p>splcie像一把瑞士军刀，可以做<code>添加、删除、插入元素</code>。</p>
<pre><code class="hljs js">arr.<span class="hljs-title function_">splice</span>(start[, deleteCount, elem1, ..., elemN])</code></pre>

<p>从<code>start</code>开始删除<code>deleteCount</code>个元素并用elm1…<code>elmN</code>进行替代，然后返回被删除的元素。如果deleteCount=0就变成了插入元素</p>
<h4 id="7-slice"><a href="#7-slice" class="headerlink" title="7. slice"></a>7. slice</h4><pre><code class="hljs js">arr.<span class="hljs-title function_">slice</span>([start], [end])</code></pre>

<p>它会返回一个新数组，将所有从索引 <code>start</code> 到 <code>end</code>（不包括 <code>end</code>）的数组项复制到一个新的数组。<code>start</code> 和 <code>end</code> 都可以是负数，在这种情况下，从末尾计算索引。缺省第二值就是截取到尾端。</p>
<h4 id="8-concat"><a href="#8-concat" class="headerlink" title="8. concat"></a>8. concat</h4><pre><code class="hljs js">arr.<span class="hljs-title function_">concat</span>(arg1, arg2...)</code></pre>

<p>创建一个新数组，其中包含来自于其他数组和其他项的值，它接受任意数量的参数 —— 数组或值都可以。</p>
<h4 id="9-forEach"><a href="#9-forEach" class="headerlink" title="9. forEach"></a>9. forEach</h4><pre><code class="hljs js">arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, array</span>) &#123;
  <span class="hljs-comment">// ... do something with item</span>
&#125;);</code></pre>

<h4 id="10-indexOf-lastIndexOf-和-includes"><a href="#10-indexOf-lastIndexOf-和-includes" class="headerlink" title="10. indexOf/lastIndexOf 和 includes"></a>10. indexOf/lastIndexOf 和 includes</h4><p>和字符串相似只是作用于数组上。注意内部比较使用的是<code>严格相等===</code></p>
<h4 id="11-find-和-findIndex"><a href="#11-find-和-findIndex" class="headerlink" title="11. find 和 findIndex"></a>11. find 和 findIndex</h4><p>主要针对<code>对象数组</code>：</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> result = arr.<span class="hljs-title function_">find</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, array</span>) &#123;
  <span class="hljs-comment">// 如果返回 true，则返回 item 并停止迭代</span>
  <span class="hljs-comment">// 对于假值（falsy）的情况，则返回 undefined</span>
&#125;);</code></pre>

<p>如果它返回 <code>true</code>，则搜索停止，并返回 <code>item</code>。如果没有搜索到，则返回 <code>undefined</code>。</p>
<p><code>arr.findIndex </code>方法s（与 <code>arr.find</code> 方法）基本上是一样的，但它返回找到元素的索引，而不是元素本身。并且在未找到任何内容时返回 <code>-1</code>。</p>
<h4 id="12-filter"><a href="#12-filter" class="headerlink" title="12. filter"></a>12. filter</h4><p>语法与 <code>find</code> 大致相同，但是 <code>filter</code> 返回的是所有匹配元素组成的数组</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> results = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, array</span>) &#123;
  <span class="hljs-comment">// 如果 true item 被 push 到 results，迭代继续</span>
  <span class="hljs-comment">// 如果什么都没找到，则返回空数组</span>
&#125;);</code></pre>

<h4 id="13-map"><a href="#13-map" class="headerlink" title="13. map"></a>13. map</h4><p>它对数组的每个元素都调用函数，并返回结果数组。</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> result = arr.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, array</span>) &#123;
  <span class="hljs-comment">// 返回新值而不是当前元素</span>
&#125;)</code></pre>

<h4 id="14-sort-fn"><a href="#14-sort-fn" class="headerlink" title="14. sort(fn)"></a>14. sort(fn)</h4><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/sort">arr.sort</a> 方法对数组进行 <strong>原位（in-place）</strong> 排序，更改元素的顺序。</p>
<p><code>这些元素默认情况下被按字符串进行排序。</code>传入一个比较器来进行手动排序，比较器返回正数为大于，负数为小于。</p>
<h4 id="15-reverse"><a href="#15-reverse" class="headerlink" title="15. reverse"></a>15. reverse</h4><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse">arr.reverse</a> 方法用于颠倒 <code>arr</code> 中元素的顺序。</p>
<h4 id="16-split与join"><a href="#16-split与join" class="headerlink" title="16. split与join"></a>16. split与join</h4><p>split以指定符号进行字符串分割为数组，join以指定符号将数组拼接成字符串</p>
<h4 id="17-reduce-reduceRight"><a href="#17-reduce-reduceRight" class="headerlink" title="17. reduce/reduceRight"></a>17. reduce/reduceRight</h4><p>该函数一个接一个地应用于所有数组元素，并将其结果“搬运（carry on）”到下一个调用，然后返回最终的结果</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> value = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">accumulator, item, index, array</span>) &#123;
  <span class="hljs-comment">// ...</span>
&#125;, [initial]);</code></pre>

<p><code>accumulator</code>是上一个函数调用的结果，第一个为<code>initial</code>如果有的话，没有为0。</p>
<blockquote>
<p>数组为空，并且没有初始值会出现error，所以建议传入初始值</p>
</blockquote>
<h4 id="18-Array-isArray"><a href="#18-Array-isArray" class="headerlink" title="18. Array.isArray"></a>18. Array.isArray</h4><p>由于数组属于对象，所以<code>typeof</code>无法区分对象和数组，所以使用<code>Array.isArray</code>进行区分。</p>
<h4 id="19-thisArg"><a href="#19-thisArg" class="headerlink" title="19. thisArg"></a>19. thisArg</h4><pre><code class="hljs js">arr.<span class="hljs-title function_">find</span>(func, thisArg);
arr.<span class="hljs-title function_">filter</span>(func, thisArg);
arr.<span class="hljs-title function_">map</span>(func, thisArg);
<span class="hljs-comment">// ...</span>
<span class="hljs-comment">// thisArg 是可选的最后一个参数</span></code></pre>

<p>除了sort都可以接受一个<code>thisArg</code>参数。</p>
<p>thisArg的值为<code>this</code>，该this和func中的this指向相同，作用主要用于<code>上下文传递</code>。未指定该参数则该参数等于undefined</p>
<h3 id="4-5-可迭代对象"><a href="#4-5-可迭代对象" class="headerlink" title="4.5. 可迭代对象"></a>4.5. 可迭代对象</h3><p>对于那些看来像数组一样的对象，让其可以使用for of进行迭代</p>
<h4 id="1-Symbol-iterator"><a href="#1-Symbol-iterator" class="headerlink" title="1. Symbol.iterator"></a>1. Symbol.iterator</h4><pre><code class="hljs js"><span class="hljs-keyword">let</span> range = &#123;
    <span class="hljs-attr">from</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">to</span>: <span class="hljs-number">5</span>
&#125;;

<span class="hljs-comment">// 1. for..of 调用首先会调用这个：</span>
range[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;

    <span class="hljs-comment">// ……它返回迭代器对象（iterator object）：</span>
    <span class="hljs-comment">// 2. 接下来，for..of 仅与此迭代器一起工作，要求它提供下一个值</span>
    <span class="hljs-keyword">return</span> &#123;
        <span class="hljs-attr">current</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">from</span>,
        <span class="hljs-attr">last</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">to</span>,

        <span class="hljs-comment">// 3. next() 在 for..of 的每一轮循环迭代中被调用</span>
        <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;
            <span class="hljs-comment">// 4. 它将会返回 &#123;done:.., value :...&#125; 格式的对象</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span> &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">last</span>) &#123;
                <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span>++ &#125;;
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;;
            &#125;
        &#125;
    &#125;;
&#125;;

<span class="hljs-comment">// 现在它可以运行了！</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> range) &#123;
    <span class="hljs-title function_">alert</span>(num); <span class="hljs-comment">// 1, 然后是 2, 3, 4, 5</span>
&#125;</code></pre>

<blockquote>
<p>字符串是可迭代对象</p>
</blockquote>
<h4 id="2-可迭代和类数组"><a href="#2-可迭代和类数组" class="headerlink" title="2. 可迭代和类数组"></a>2. 可迭代和类数组</h4><ul>
<li>可迭代：实现<code>Symbol.iterator</code>方法的对象</li>
<li>类数组：是有索引和 <code>length</code> 属性的对象，所以它们看起来很像数组。</li>
</ul>
<h4 id="3-Array-from"><a href="#3-Array-from" class="headerlink" title="3. Array.from"></a>3. Array.from</h4><p>有一个全局方法 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/from">Array.from</a> 可以接受一个可迭代或类数组的值，并从中获取一个“真正的”数组，返回的是一个新的数组对象。</p>
<pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(obj[, mapFn, thisArg])</code></pre>

<p>可选的第二个参数 <code>mapFn</code> 可以是一个函数，该函数会在对象中的元素被添加到数组前，被应用于每个元素，此外 <code>thisArg</code> 允许我们为该函数设置 <code>this</code>。</p>
<pre><code class="hljs js"><span class="hljs-comment">// 求每个数的平方</span>
<span class="hljs-keyword">let</span> arr = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(range, <span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num * num);

<span class="hljs-title function_">alert</span>(arr); <span class="hljs-comment">// 1,4,9,16,25</span></code></pre>

<blockquote>
<p>还可以像slice一样将字符串转为数组</p>
</blockquote>
<h3 id="4-6-Map和Set"><a href="#4-6-Map和Set" class="headerlink" title="4.6 Map和Set"></a>4.6 Map和Set</h3><h4 id="1-Map"><a href="#1-Map" class="headerlink" title="1. Map"></a>1. Map</h4><p><code>Map </code>是一个带键的数据项的集合，就像一个 <code>Object</code> 一样。 但是它们最大的差别是 <code>Map</code> 允许任何类型的键（key）。</p>
<p>它的方法和属性如下：</p>
<ul>
<li><code>new Map()</code> —— 创建 map。</li>
<li><code>map.set(key, value)</code> —— 根据键存储值。</li>
<li><code>map.get(key)</code> —— 根据键来返回值，如果 <code>map</code> 中不存在对应的 <code>key</code>，则返回 <code>undefined</code>。</li>
<li><code>map.has(key)</code> —— 如果 <code>key</code> 存在则返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li><code>map.delete(key)</code> —— 删除指定键的值。</li>
<li><code>map.clear()</code> —— 清空 map。</li>
<li><code>map.size</code> —— 返回当前元素个数。</li>
</ul>
<blockquote>
<p>Map支持链式调用</p>
</blockquote>
<h4 id="2-Map迭代"><a href="#2-Map迭代" class="headerlink" title="2. Map迭代"></a>2. Map迭代</h4><ul>
<li><code>map.keys()</code> —— 遍历并返回所有的键（returns an iterable for keys），</li>
<li><code>map.values()</code> —— 遍历并返回所有的值（returns an iterable for values），</li>
<li><code>map.entries()</code> —— 遍历并返回所有的实体（returns an iterable for entries）<code>[key, value]</code>，<code>for..of</code> 在默认情况下使用的就是这个。</li>
</ul>
<blockquote>
<p>和对象不同，map的迭代顺序和插入顺序是一致的</p>
</blockquote>
<h4 id="3-Map创建"><a href="#3-Map创建" class="headerlink" title="3. Map创建"></a>3. Map创建</h4><p><strong>从数组中创建Map</strong></p>
<pre><code class="hljs js"><span class="hljs-comment">// 键值对 [key, value] 数组</span>
<span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([
  [<span class="hljs-string">&#x27;1&#x27;</span>,  <span class="hljs-string">&#x27;str1&#x27;</span>],
  [<span class="hljs-number">1</span>,    <span class="hljs-string">&#x27;num1&#x27;</span>],
  [<span class="hljs-literal">true</span>, <span class="hljs-string">&#x27;bool1&#x27;</span>]
]);

<span class="hljs-title function_">alert</span>( map.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;1&#x27;</span>) ); <span class="hljs-comment">// str1</span></code></pre>

<p><strong>从对象中创建Map</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>
&#125;;

<span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(obj));

<span class="hljs-title function_">alert</span>( map.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;name&#x27;</span>) ); <span class="hljs-comment">// John</span></code></pre>

<p><strong>从Map中创建对象</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> prices = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>([
  [<span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-number">1</span>],
  [<span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-number">2</span>],
  [<span class="hljs-string">&#x27;meat&#x27;</span>, <span class="hljs-number">4</span>]
]);

<span class="hljs-comment">// 现在 prices = &#123; banana: 1, orange: 2, meat: 4 &#125;</span>

<span class="hljs-title function_">alert</span>(prices.<span class="hljs-property">orange</span>); <span class="hljs-comment">// 2</span></code></pre>

<h4 id="4-Set"><a href="#4-Set" class="headerlink" title="4. Set"></a>4. Set</h4><ul>
<li><code>new Set(iterable)</code> —— 创建一个 <code>set</code>，如果提供了一个 <code>iterable</code> 对象（通常是数组），将会从数组里面复制值到 <code>set</code> 中。</li>
<li><code>set.add(value)</code> —— 添加一个值，返回 set 本身</li>
<li><code>set.delete(value)</code> —— 删除值，如果 <code>value</code> 在这个方法调用的时候存在则返回 <code>true</code> ，否则返回 <code>false</code>。</li>
<li><code>set.has(value)</code> —— 如果 <code>value</code> 在 set 中，返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li><code>set.clear()</code> —— 清空 set。</li>
<li><code>set.size</code> —— 返回元素个数。</li>
</ul>
<h4 id="5-Set迭代"><a href="#5-Set迭代" class="headerlink" title="5. Set迭代"></a>5. Set迭代</h4><ul>
<li><code>set.keys()</code> —— 遍历并返回所有的值（returns an iterable object for values），</li>
<li><code>set.values()</code> —— 与 <code>set.keys()</code> 作用相同，这是为了兼容 <code>Map</code>，</li>
<li><code>set.entries()</code> —— 遍历并返回所有的实体（returns an iterable object for entries）<code>[value, value]</code>，它的存在也是为了兼容 <code>Map</code>。</li>
</ul>
<h3 id="4-7-WeakMap和WeakSet（弱映射和弱集合）"><a href="#4-7-WeakMap和WeakSet（弱映射和弱集合）" class="headerlink" title="4.7 WeakMap和WeakSet（弱映射和弱集合）"></a>4.7 WeakMap和WeakSet（弱映射和弱集合）</h3><p>对于普通的Map，存放在里面的对象没有了其它引用也不会被垃圾回收器回收，但是WeakMap则会被回收。</p>
<blockquote>
<p>暂不支持访问 <code>WeakMap</code> 的所有键/值的方法。</p>
</blockquote>
<h4 id="1-额外的数据存储"><a href="#1-额外的数据存储" class="headerlink" title="1. 额外的数据存储"></a>1. 额外的数据存储</h4><p>例如，我们有用于处理用户访问计数的代码。收集到的信息被存储在 map 中：一个用户对象作为键，其访问次数为值。当一个用户离开时（该用户对象将被垃圾回收机制回收），这时我们就不再需要他的访问次数了。</p>
<h4 id="2-缓存"><a href="#2-缓存" class="headerlink" title="2. 缓存"></a>2. 缓存</h4><p>当一个函数的结果需要被记住（“缓存”），这样在后续的对同一个对象的调用时，就可以重用这个被缓存的结果。</p>
<h3 id="4-8-解构赋值"><a href="#4-8-解构赋值" class="headerlink" title="4.8 解构赋值"></a>4.8 解构赋值</h3><h4 id="1-数组解构"><a href="#1-数组解构" class="headerlink" title="1. 数组解构"></a>1. 数组解构</h4><pre><code class="hljs js"><span class="hljs-comment">// 我们有一个存放了名字和姓氏的数组</span>
<span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;Ilya&quot;</span>, <span class="hljs-string">&quot;Kantor&quot;</span>]

<span class="hljs-comment">// 解构赋值</span>
<span class="hljs-comment">// sets firstName = arr[0]</span>
<span class="hljs-comment">// and surname = arr[1]</span>
<span class="hljs-keyword">let</span> [firstName, surname] = arr;

<span class="hljs-title function_">alert</span>(firstName); <span class="hljs-comment">// Ilya</span>
<span class="hljs-title function_">alert</span>(surname);  <span class="hljs-comment">// Kantor</span></code></pre>

<p>更加优雅的方式</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> [firstName, surname] = <span class="hljs-string">&quot;Ilya Kantor&quot;</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>);</code></pre>

<p><strong>忽略使用逗号的元素</strong></p>
<pre><code class="hljs js"><span class="hljs-comment">// 不需要第二个元素</span>
<span class="hljs-keyword">let</span> [firstName, , title] = [<span class="hljs-string">&quot;Julius&quot;</span>, <span class="hljs-string">&quot;Caesar&quot;</span>, <span class="hljs-string">&quot;Consul&quot;</span>, <span class="hljs-string">&quot;of the Roman Republic&quot;</span>];

<span class="hljs-title function_">alert</span>( title ); <span class="hljs-comment">// Consul</span></code></pre>

<p><strong>等号右侧可以是任何可迭代对象</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> [a, b, c] = <span class="hljs-string">&quot;abc&quot;</span>; <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
<span class="hljs-keyword">let</span> [one, two, three] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);</code></pre>

<p><strong>赋值给等号左侧的任何内容</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> user = &#123;&#125;;
[user.<span class="hljs-property">name</span>, user.<span class="hljs-property">surname</span>] = <span class="hljs-string">&quot;Ilya Kantor&quot;</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>);

<span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>); <span class="hljs-comment">// Ilya</span></code></pre>

<p><strong>与 .entries() 方法进行循环操作</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> user = &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>
&#125;;

<span class="hljs-comment">// 循环遍历键—值对</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(user)) &#123;
  <span class="hljs-title function_">alert</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>:<span class="hljs-subst">$&#123;value&#125;</span>`</span>); <span class="hljs-comment">// name:John, then age:30</span>
&#125;</code></pre>

<p><strong>变量值交换</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> guest = <span class="hljs-string">&quot;Jane&quot;</span>;
<span class="hljs-keyword">let</span> admin = <span class="hljs-string">&quot;Pete&quot;</span>;

<span class="hljs-comment">// 交换值：让 guest=Pete, admin=Jane</span>
[guest, admin] = [admin, guest];

<span class="hljs-title function_">alert</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;guest&#125;</span> <span class="hljs-subst">$&#123;admin&#125;</span>`</span>); <span class="hljs-comment">// Pete Jane（成功交换！）</span></code></pre>

<p><strong>剩余的”…”</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> [name1, name2, ...rest] = [<span class="hljs-string">&quot;Julius&quot;</span>, <span class="hljs-string">&quot;Caesar&quot;</span>, <span class="hljs-string">&quot;Consul&quot;</span>, <span class="hljs-string">&quot;of the Roman Republic&quot;</span>];

<span class="hljs-title function_">alert</span>(name1); <span class="hljs-comment">// Julius</span>
<span class="hljs-title function_">alert</span>(name2); <span class="hljs-comment">// Caesar</span>

<span class="hljs-comment">// 请注意，`rest` 的类型是数组</span>
<span class="hljs-title function_">alert</span>(rest[<span class="hljs-number">0</span>]); <span class="hljs-comment">// Consul</span>
<span class="hljs-title function_">alert</span>(rest[<span class="hljs-number">1</span>]); <span class="hljs-comment">// of the Roman Republic</span>
<span class="hljs-title function_">alert</span>(rest.<span class="hljs-property">length</span>); <span class="hljs-comment">// 2</span></code></pre>

<p><strong>默认值</strong></p>
<p>一般情况下变量的数量多余数组中实际元素的数量，被解构的数据就是<code>undefined</code></p>
<pre><code class="hljs js"><span class="hljs-comment">// 默认值</span>
<span class="hljs-keyword">let</span> [name = <span class="hljs-string">&quot;Guest&quot;</span>, surname = <span class="hljs-string">&quot;Anonymous&quot;</span>, lastName = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;name?&#x27;</span>)] = [<span class="hljs-string">&quot;Julius&quot;</span>];

<span class="hljs-title function_">alert</span>(name);    <span class="hljs-comment">// Julius（来自数组的值）</span>
<span class="hljs-title function_">alert</span>(surname); <span class="hljs-comment">// Anonymous（默认值被使用了）</span></code></pre>

<blockquote>
<p>只有当没有被赋值时，才会触发prompt</p>
</blockquote>
<h4 id="2-对象解构"><a href="#2-对象解构" class="headerlink" title="2. 对象解构"></a>2. 对象解构</h4><pre><code class="hljs js"><span class="hljs-keyword">let</span> &#123;prop : varName = <span class="hljs-keyword">default</span>, ...rest&#125; = object</code></pre>

<p>使用举例：</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> options = &#123;
  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Menu&quot;</span>,
  <span class="hljs-attr">width</span>: <span class="hljs-number">100</span>,
  <span class="hljs-attr">height</span>: <span class="hljs-number">200</span>
&#125;;

<span class="hljs-keyword">let</span> &#123;title, width, height&#125; = options;</code></pre>

<blockquote>
<p>变量顺序并不影响解构结果</p>
</blockquote>
<p>如果我们想把一个属性赋值给另一个名字的变量，比如把 <code>options.width</code> 属性赋值给变量 <code>w</code>，那么我们可以使用冒号来指定（原来的会删除）：</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> options = &#123;
    <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Menu&quot;</span>,
    <span class="hljs-attr">width</span>: <span class="hljs-number">100</span>,
    <span class="hljs-attr">height</span>: <span class="hljs-number">200</span>
&#125;;

<span class="hljs-comment">// &#123; sourceProperty: targetVariable &#125;</span>
<span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">width</span>: w, <span class="hljs-attr">height</span>: h, title&#125; = options;

<span class="hljs-comment">// width -&gt; w</span>
<span class="hljs-comment">// height -&gt; h</span>
<span class="hljs-comment">// title -&gt; title</span>

<span class="hljs-title function_">alert</span>(title);  <span class="hljs-comment">// Menu</span>
<span class="hljs-title function_">alert</span>(w);      <span class="hljs-comment">// 100</span>
<span class="hljs-title function_">alert</span>(h);      <span class="hljs-comment">// 200</span></code></pre>

<p>对于可能缺失的属性，我们可以像数组解构一样进行指定或者函数调用。</p>
<p><strong>剩余模式（pattern）”…“</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> options = &#123;
  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Menu&quot;</span>,
  <span class="hljs-attr">height</span>: <span class="hljs-number">200</span>,
  <span class="hljs-attr">width</span>: <span class="hljs-number">100</span>
&#125;;

<span class="hljs-comment">// title = 名为 title 的属性</span>
<span class="hljs-comment">// rest = 存有剩余属性的对象</span>
<span class="hljs-keyword">let</span> &#123;title, ...rest&#125; = options;

<span class="hljs-comment">// 现在 title=&quot;Menu&quot;, rest=&#123;height: 200, width: 100&#125;</span>
<span class="hljs-title function_">alert</span>(rest.<span class="hljs-property">height</span>);  <span class="hljs-comment">// 200</span>
<span class="hljs-title function_">alert</span>(rest.<span class="hljs-property">width</span>);   <span class="hljs-comment">// 100</span></code></pre>

<h4 id="3-解构陷阱"><a href="#3-解构陷阱" class="headerlink" title="3. 解构陷阱"></a>3. 解构陷阱</h4><pre><code class="hljs js"><span class="hljs-keyword">let</span> title, width, height;

<span class="hljs-comment">// 这一行发生了错误</span>
&#123;title, width, height&#125; = &#123;<span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Menu&quot;</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">100</span>&#125;;</code></pre>

<p>这里将不在其他表达式中<code>&#123;...&#125;</code>当作一个代码块，下面给出解决办法：</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> title, width, height;

<span class="hljs-comment">// 现在就可以了</span>
(&#123;title, width, height&#125; = &#123;<span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Menu&quot;</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">100</span>&#125;);

<span class="hljs-title function_">alert</span>( title ); <span class="hljs-comment">// Menu</span></code></pre>

<h4 id="4-嵌套解构"><a href="#4-嵌套解构" class="headerlink" title="4. 嵌套解构"></a>4. 嵌套解构</h4><pre><code class="hljs js"><span class="hljs-keyword">let</span> user = &#123;
  <span class="hljs-attr">name</span>: &#123;
    <span class="hljs-attr">first</span>: <span class="hljs-string">&#x27;john&#x27;</span>,
    <span class="hljs-attr">last</span>: <span class="hljs-string">&#x27;li&#x27;</span>
  &#125;
&#125;

<span class="hljs-keyword">let</span> &#123; name &#125; = user;
<span class="hljs-comment">// 不支持</span>
<span class="hljs-keyword">let</span> &#123;first&#125; = user;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name.<span class="hljs-property">first</span>);</code></pre>

<h3 id="4-9-JSON"><a href="#4-9-JSON" class="headerlink" title="4.9 JSON"></a>4.9 JSON</h3><h4 id="1-stringify"><a href="#1-stringify" class="headerlink" title="1. stringify"></a>1. stringify</h4><pre><code class="hljs js"><span class="hljs-keyword">let</span> json = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(value[, replacer, space])</code></pre>

<ul>
<li><code>value</code>：被解析对象</li>
<li><code>replacer</code>：传入一个函数<code>function(key, value)</code>，用于分析并替换/跳过整个对象</li>
<li><code>space</code>：用于格式化输出，缩进占的空格数。</li>
</ul>
<h4 id="2-自定义”toJSON“"><a href="#2-自定义”toJSON“" class="headerlink" title="2. 自定义”toJSON“"></a>2. 自定义”toJSON“</h4><p>对象可以提供toJSON方法，当stringify进行解析时会自动调用该对象</p>
<h4 id="3-parse"><a href="#3-parse" class="headerlink" title="3. parse"></a>3. parse</h4><pre><code class="hljs js"><span class="hljs-keyword">let</span> value = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(str, [reviver]);</code></pre>

<ul>
<li><code>str</code>：需要解析的JSON字符串</li>
<li><code>reviver</code>：可选的函数 function(key,value)，该函数将为每个 <code>(key, value)</code> 对调用，并可以对值进行转换。</li>
</ul>
<blockquote>
<p>JSON字符串的属性必须双引号，值必须是裸值不能使用<code>new</code>关键字</p>
</blockquote>
<h2 id="5-函数进阶"><a href="#5-函数进阶" class="headerlink" title="5. 函数进阶"></a>5. 函数进阶</h2><h3 id="5-1-Rest与Spread"><a href="#5-1-Rest与Spread" class="headerlink" title="5.1. Rest与Spread"></a>5.1. Rest与Spread</h3><h4 id="1-Rest参数…"><a href="#1-Rest参数…" class="headerlink" title="1. Rest参数…"></a>1. Rest参数…</h4><p>必须是最后一个参数，传入是最后一个参数在函数内部是一个数组</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> arr=<span class="hljs-keyword">function</span>(<span class="hljs-params">a,b,...args</span>)&#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> arg <span class="hljs-keyword">of</span> args) &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg);
  &#125;
&#125;;

<span class="hljs-title function_">arr</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>) <span class="hljs-comment">// 1 2 3 4 5 6</span></code></pre>

<h4 id="2-arguments变量"><a href="#2-arguments变量" class="headerlink" title="2. arguments变量"></a>2. arguments变量</h4><p>有一个名为 <code>arguments</code> 的特殊的类数组对象，该对象按参数索引包含所有参数。</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> arr=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> <span class="hljs-variable language_">arguments</span>) &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);
  &#125;
&#125;;

<span class="hljs-title function_">arr</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>) <span class="hljs-comment">// 1 2 3 4 5 6</span></code></pre>

<blockquote>
<p><code>arguments</code>终究不是一个数组，不能使用数组相关的方法。</p>
</blockquote>
<blockquote>
<p>箭头函数是没有 “arguments”，如果我们在箭头函数中访问 <code>arguments</code>，访问到的 <code>arguments</code> 并不属于箭头函数，而是属于箭头函数外部的“普通”函数。</p>
</blockquote>
<h4 id="3-Spread语法"><a href="#3-Spread语法" class="headerlink" title="3. Spread语法"></a>3. Spread语法</h4><p>将数据解构传入函数</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
<span class="hljs-keyword">let</span> arr2 = [<span class="hljs-number">8</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">8</span>, <span class="hljs-number">1</span>];

<span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">1</span>, ...arr1, <span class="hljs-number">2</span>, ...arr2, <span class="hljs-number">25</span>) ); <span class="hljs-comment">// 25</span>
<span class="hljs-keyword">let</span> merged = [<span class="hljs-number">0</span>, ...arr, <span class="hljs-number">2</span>, ...arr2];</code></pre>

<blockquote>
<p>它可以解构任何可迭代对象，比如字符串</p>
</blockquote>
<h4 id="4-获取一个-array-object-的副本"><a href="#4-获取一个-array-object-的副本" class="headerlink" title="4. 获取一个 array/object 的副本"></a>4. 获取一个 array/object 的副本</h4><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">let</span> arrCopy = [...arr]; <span class="hljs-comment">// 将数组 spread 到参数列表中,  然后将结果放到一个新数组</span>

<span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;;
<span class="hljs-keyword">let</span> objCopy = &#123; ...obj &#125;; <span class="hljs-comment">// 将对象 spread 到参数列表中,  然后将结果返回到一个新对象</span></code></pre>

<h3 id="5-2-闭包"><a href="#5-2-闭包" class="headerlink" title="5.2. 闭包"></a>5.2. 闭包</h3><h4 id="1-嵌套函数"><a href="#1-嵌套函数" class="headerlink" title="1. 嵌套函数"></a>1. 嵌套函数</h4><p>在函数内部仍然可以创建函数，返回值可以返回一个函数。</p>
<h4 id="2-词法环境"><a href="#2-词法环境" class="headerlink" title="2. 词法环境"></a>2. 词法环境</h4><p><strong>Step1.变量</strong></p>
<p>在 JavaScript 中，每个运行的函数，代码块 <code>&#123;...&#125;</code> 以及整个脚本，都有一个被称为 <code>词法环境（Lexical Environment）</code>的内部（隐藏）的关联对象。</p>
<p>词法环境对象由两部分组成：</p>
<ol>
<li><code>环境记录（Environment Record）</code> —— 一个存储所有局部变量作为其属性（包括一些其他信息，例如 <code>this</code> 的值）的对象。</li>
<li>对 <code>外部词法环境 </code>的引用，与外部代码相关联。</li>
</ol>
<p>操作函数内部变量实际就是操作该词法环境对象。</p>
<p><img src="https://i.loli.net/2021/07/05/d1ZNG2g8hTDB6oL.png" alt="image-20210705120913782"></p>
<p><strong>Step2.函数声明</strong></p>
<p>与变量的声明类似</p>
<p><strong>Step3.内部和外部的词法环境</strong></p>
<p>当代码要访问一个变量时 —— 首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境。如果在任何地方都找不到这个变量，那么在严格模式下就会报错（在非严格模式下，为了向下兼容，给未定义的变量赋值会创建一个全局变量）。</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> makeCount=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;
    <span class="hljs-keyword">let</span> count=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;
        <span class="hljs-keyword">return</span> ++count;
    &#125;;
&#125;;

<span class="hljs-keyword">let</span> counter=<span class="hljs-title function_">makeCount</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">counter</span>()); <span class="hljs-comment">// 1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">counter</span>()); <span class="hljs-comment">// 2</span></code></pre>

<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">闭包</a> 是指内部函数总是可以访问其所在的外部函数中声明的变量和参数，即使在其外部函数被返回（寿命终结）了之后。</p>
<p>JavaScript 中的函数会自动通过隐藏的 <code>[[Environment]]</code> 属性记住创建它们的位置，所以它们都可以访问外部变量。</p>
</blockquote>
<h3 id="5-3-var"><a href="#5-3-var" class="headerlink" title="5.3 var"></a>5.3 var</h3><h4 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1. 作用域"></a>1. 作用域</h4><p>var的作用域只有函数作用域和全局作用域，没有块级作用域。即var会穿透if，for和其它代码块。</p>
<h4 id="2-IIFE（立即调用函数表达式）"><a href="#2-IIFE（立即调用函数表达式）" class="headerlink" title="2. IIFE（立即调用函数表达式）"></a>2. IIFE（立即调用函数表达式）</h4><pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;Hello&quot;</span>;
  <span class="hljs-title function_">alert</span>(message); <span class="hljs-comment">// Hello</span>
&#125;)();

<span class="hljs-comment">// 下面的括号会导致语法错误</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">go</span>(<span class="hljs-params"></span>) &#123;
&#125;(); <span class="hljs-comment">// &lt;-- 不能立即调用函数声明</span>

<span class="hljs-comment">// 其它的创建 IIFE 的方法</span>
(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Parentheses around the function&quot;</span>);
&#125;)();

(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Parentheses around the whole thing&quot;</span>);
&#125;());

!<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Bitwise NOT operator starts the expression&quot;</span>);
&#125;();

+<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Unary plus starts the expression&quot;</span>);
&#125;();</code></pre>

<h3 id="5-4-全局对象"><a href="#5-4-全局对象" class="headerlink" title="5.4 全局对象"></a>5.4 全局对象</h3><p>在浏览器中，使用 <code>var</code>（而不是 <code>let/const</code>！）声明的全局函数和变量会成为全局对象的属性。</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> gVar = <span class="hljs-number">5</span>;

<span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">gVar</span>); <span class="hljs-comment">// 5（成为了全局对象的属性）</span></code></pre>

<h3 id="5-5-函数对象"><a href="#5-5-函数对象" class="headerlink" title="5.5 函数对象"></a>5.5 函数对象</h3><p>函数即对象，我们可以操作对象的方式来处理函数</p>
<h4 id="1-name"><a href="#1-name" class="headerlink" title="1. name"></a>1. name</h4><p>使用<code>name</code>来获取函数名</p>
<pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hi&quot;</span>);
&#125;

<span class="hljs-title function_">alert</span>(sayHi.<span class="hljs-property">name</span>); <span class="hljs-comment">// sayHi</span></code></pre>

<h4 id="2-length"><a href="#2-length" class="headerlink" title="2. length"></a>2. length</h4><p>获取函数参数的个数，但是<code>rest参数不参与计数</code></p>
<h4 id="3-自定义属性"><a href="#3-自定义属性" class="headerlink" title="3. 自定义属性"></a>3. 自定义属性</h4><p>可以为函数添加属性，比如计算函数的调用次数</p>
<pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hi&quot;</span>);

  <span class="hljs-comment">// 计算调用次数</span>
  sayHi.<span class="hljs-property">counter</span>++;
&#125;
sayHi.<span class="hljs-property">counter</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始值</span>

<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// Hi</span>
<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// Hi</span>

<span class="hljs-title function_">alert</span>( <span class="hljs-string">`Called <span class="hljs-subst">$&#123;sayHi.counter&#125;</span> times`</span> ); <span class="hljs-comment">// Called 2 times</span></code></pre>

<p>可以使用函数属性以用来替代闭包</p>
<pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeCounter</span>(<span class="hljs-params"></span>) &#123;
    <span class="hljs-comment">// 不需要这个了</span>
    <span class="hljs-comment">// let count = 0</span>

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">counter</span>(<span class="hljs-params"></span>) &#123;
        <span class="hljs-keyword">return</span> counter.<span class="hljs-property">count</span>++;
    &#125;;

    counter.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">return</span> counter;
&#125;

<span class="hljs-keyword">let</span> counter = <span class="hljs-title function_">makeCounter</span>();
<span class="hljs-title function_">alert</span>( <span class="hljs-title function_">counter</span>() ); <span class="hljs-comment">// 0</span>
<span class="hljs-title function_">alert</span>( <span class="hljs-title function_">counter</span>() ); <span class="hljs-comment">// 1</span></code></pre>

<p>和闭包的区别就在于一个存储在函数外部，一个存储在函数内部。</p>
<h4 id="4-命名函数表达式"><a href="#4-命名函数表达式" class="headerlink" title="4. 命名函数表达式"></a>4. 命名函数表达式</h4><pre><code class="hljs js"><span class="hljs-keyword">let</span> sayHi = <span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">who</span>) &#123;
    <span class="hljs-keyword">if</span> (who) &#123;
        <span class="hljs-title function_">alert</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;who&#125;</span>`</span>);
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-title function_">func</span>(<span class="hljs-string">&quot;Guest&quot;</span>); <span class="hljs-comment">// 使用 func 再次调用函数自身</span>
        <span class="hljs-title function_">sayHi</span>(<span class="hljs-string">&quot;test&quot;</span>);
    &#125;
&#125;;

<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// Hello, Guest</span>

<span class="hljs-comment">// 但这不工作：</span>
<span class="hljs-title function_">func</span>(); <span class="hljs-comment">// Error, func is not defined（在函数外不可见）</span></code></pre>

<p>关于名字 <code>func</code> 有两个特殊的地方，这就是添加它的原因：</p>
<ol>
<li>它允许函数在内部引用自己。</li>
<li>它在函数外是不可见的。</li>
</ol>
<blockquote>
<p>外部将sayHi置空，会导致内部无法调用。</p>
<p>func属于函数作用域，sayHi属于全局作用域</p>
</blockquote>
<h3 id="5-6-new-Function"><a href="#5-6-new-Function" class="headerlink" title="5.6 new Function"></a>5.6 new Function</h3><pre><code class="hljs js"><span class="hljs-keyword">let</span> func = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span> ([arg1, arg2, ...argN], functionBody);</code></pre>

<pre><code class="hljs js"><span class="hljs-keyword">let</span> sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;return a + b&#x27;</span>); <span class="hljs-comment">// 基础语法</span>
<span class="hljs-keyword">let</span> sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">&#x27;a,b&#x27;</span>, <span class="hljs-string">&#x27;return a + b&#x27;</span>); <span class="hljs-comment">// 逗号分隔</span>
<span class="hljs-keyword">let</span> sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">&#x27;a , b&#x27;</span>, <span class="hljs-string">&#x27;return a + b&#x27;</span>); <span class="hljs-comment">// 逗号和空格分隔</span>

<span class="hljs-title function_">alert</span>( <span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) ); <span class="hljs-comment">// 3</span></code></pre>

<p>使用 <code>new Function</code> 创建函数的应用场景非常特殊，比如在复杂的 Web 应用程序中，我们需要<code>从服务器获取代码或者动态地从模板编译函数</code>时才会使用。</p>
<blockquote>
<p>如果我们使用 <code>new Function</code> 创建一个函数，那么该函数的 <code>[[Environment]]</code> 并不指向当前的词法环境，而是指向全局环境。这样做的目的就是在进行压缩代码时，无法找到外部词法环境的变量，因为再次之前它已经被改变了。</p>
</blockquote>
<h3 id="5-7-定时函数"><a href="#5-7-定时函数" class="headerlink" title="5.7 定时函数"></a>5.7 定时函数</h3><h4 id="1-setTimeout"><a href="#1-setTimeout" class="headerlink" title="1. setTimeout"></a>1. setTimeout</h4><pre><code class="hljs js"><span class="hljs-keyword">let</span> timerId = <span class="hljs-built_in">setTimeout</span>(func|code, [delay], [arg1], [arg2], ...)</code></pre>

<p>允许我们将函数推迟到一段时间间隔之后再执行。</p>
<ul>
<li><code>fun | code</code> ：要执行的函数或者代码字符串（不建议）。</li>
<li><code>delay</code> ：执行前的延时，以毫秒为单位（1000 毫秒 = 1 秒），默认值是 0。</li>
<li><code>arg</code> ：要执行函数的参数列表。</li>
</ul>
<blockquote>
<p>fun参数，主要不要加括号，但是可以使用箭头函数。</p>
</blockquote>
<p><strong>嵌套setTimeout</strong></p>
<p>通过嵌套执行 <code>setTimeout</code> 可以完成周期性调度，类似于 <code>setInterval</code> ，并且它可以更加灵活的执行。</p>
<p>两者不同的是：</p>
<ul>
<li><code>setTimeout</code>：内部程序间隔时间包含自身函数执行的时间。</li>
<li><code>setInterval</code>：相反内部程序间隔时间不包含自身函数执行时间，而是从函数执行完毕才开始计算时间。</li>
</ul>
<h4 id="2-clearTimeout"><a href="#2-clearTimeout" class="headerlink" title="2. clearTimeout"></a>2. clearTimeout</h4><p>setTimeout 会返回一个 <code>定时器标识符</code> ，利用此标识可以进行取消 setTimeout。</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> timerId = <span class="hljs-built_in">setTimeout</span>(...);
<span class="hljs-built_in">clearTimeout</span>(timerId);</code></pre>

<h4 id="3-setInterval"><a href="#3-setInterval" class="headerlink" title="3. setInterval"></a>3. setInterval</h4><p>许我们重复运行一个函数，从一段时间间隔之后开始运行，之后以该时间间隔连续重复运行该函数。</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> timerId = <span class="hljs-built_in">setInterval</span>(func|code, [delay], [arg1], [arg2], ...)</code></pre>

<h4 id="4-clearInterval"><a href="#4-clearInterval" class="headerlink" title="4. clearInterval"></a>4. clearInterval</h4><p>和 <code>clearTimeout</code> 类似，它可以取消 <code>setInterval</code> ，方法类似。</p>
<blockquote>
<p>当我们以零延时的嵌套定时器或 setInterval 进行循环执行时，它的频率不仅实际不为零，而且在 <code>HTML5标准</code> 中所讲：“经过 5 重嵌套定时器之后，时间间隔被强制设定为至少 4 毫秒“。该限制源于 <code>远古时代</code> 现在的服务端的js都没有这个限制。</p>
</blockquote>
<h3 id="5-8-JS的装饰器"><a href="#5-8-JS的装饰器" class="headerlink" title="5.8 JS的装饰器"></a>5.8 JS的装饰器</h3><p>由于函数可以作为参数传入另一个函数或者返回一个函数，利用此特性我们可以为函数装饰一个新的功能。</p>
<h4 id="1-透明缓存"><a href="#1-透明缓存" class="headerlink" title="1. 透明缓存"></a>1. 透明缓存</h4><p>为函数增加缓存功能，函数的调用结果将会被保存，下次调用会优先取缓存，这样做的目的就是避免CPU负载重的任务重复执行。</p>
<blockquote>
<p>前提是该函数的结果是稳定的，即传入的内容相同，得出的结果不同。比如某些函数依赖了外部内容比如时间，那么得出的结果可能不同。</p>
</blockquote>
<pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">slow</span>(<span class="hljs-params">x</span>) &#123;
    <span class="hljs-comment">// 这里可能会有重负载的 CPU 密集型工作</span>
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">`Called with <span class="hljs-subst">$&#123;x&#125;</span>`</span>);
    <span class="hljs-keyword">return</span> x;
&#125;

<span class="hljs-comment">// 参数为被装饰的函数。</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">cachingDecorator</span>(<span class="hljs-params">func</span>) &#123;
    <span class="hljs-comment">// 参数为key，result为value。</span>
    <span class="hljs-keyword">let</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) &#123;
        <span class="hljs-keyword">if</span> (cache.<span class="hljs-title function_">has</span>(x)) &#123;    <span class="hljs-comment">// 如果缓存中有对应的结果</span>
            <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">get</span>(x); <span class="hljs-comment">// 从缓存中读取结果</span>
        &#125;

        <span class="hljs-keyword">let</span> result = <span class="hljs-title function_">func</span>(x);  <span class="hljs-comment">// 否则就调用 func</span>

        cache.<span class="hljs-title function_">set</span>(x, result);  <span class="hljs-comment">// 然后将结果缓存（记住）下来</span>
        <span class="hljs-keyword">return</span> result;
    &#125;;
&#125;

slow = <span class="hljs-title function_">cachingDecorator</span>(slow);

<span class="hljs-title function_">alert</span>( <span class="hljs-title function_">slow</span>(<span class="hljs-number">1</span>) ); <span class="hljs-comment">// slow(1) 被缓存下来了</span>
<span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Again: &quot;</span> + <span class="hljs-title function_">slow</span>(<span class="hljs-number">1</span>) ); <span class="hljs-comment">// 一样的</span>

<span class="hljs-title function_">alert</span>( <span class="hljs-title function_">slow</span>(<span class="hljs-number">2</span>) ); <span class="hljs-comment">// slow(2) 被缓存下来了</span>
<span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Again: &quot;</span> + <span class="hljs-title function_">slow</span>(<span class="hljs-number">2</span>) ); <span class="hljs-comment">// 和前面一行结果相同</span></code></pre>

<h4 id="2-func-call"><a href="#2-func-call" class="headerlink" title="2. func.call"></a>2. func.call</h4><p>我们为类中的函数做装饰器时，就比如上面的例子，如果在被装饰的函数使用了 <code>this</code> ，那么装饰的结果函数this的指向将会出现问题。</p>
<pre><code class="hljs js">func.<span class="hljs-title function_">call</span>(context, arg1, arg2, ...)</code></pre>

<ul>
<li><code>context</code>：代表的就是需要包装的函数中使用的this对象</li>
</ul>
<p>当我们需要传入多个参数时，可以将多个参数生成一个 <code>hash值</code> ，在将这个值作为map的key。</p>
<h4 id="3-func-apply"><a href="#3-func-apply" class="headerlink" title="3. func.apply"></a>3. func.apply</h4><pre><code class="hljs js">func.<span class="hljs-title function_">apply</span>(context, args)</code></pre>

<p>该方法和 <code>call</code> 的作用类似，唯一的区别就是apply期望的是包含这些参数的类数组对象。</p>
<blockquote>
<p>将所有参数连同上下文一起传递给另一个函数被称为“呼叫转移（call forwarding）</p>
</blockquote>
<p>在 <code>hash</code> 函数中，根据参数对象 <code>arguments</code> （非数组）生成的hash值时，由于它不是真正的数组，不可以直接使用数组的方法，但是我们可以使用 <code>方法借用</code> ：</p>
<pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hash</span>(<span class="hljs-params"></span>) &#123;
    <span class="hljs-title function_">alert</span>( [].<span class="hljs-property">join</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>) ); <span class="hljs-comment">// 1,2</span>
&#125;

<span class="hljs-title function_">hash</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);</code></pre>

<p>// TODO</p>
<h3 id="5-9-函数绑定"><a href="#5-9-函数绑定" class="headerlink" title="5.9 函数绑定"></a>5.9 函数绑定</h3><p>当我们将对象的方法进行回调进行传递时，通常会丢失它的 <code>this 指向</code>。</p>
<h4 id="1-bind"><a href="#1-bind" class="headerlink" title="1. bind"></a>1. bind</h4><pre><code class="hljs js"><span class="hljs-comment">// 省略版</span>
<span class="hljs-keyword">let</span> boundFunc = func.<span class="hljs-title function_">bind</span>(context);</code></pre>

<p>如果绑定的对象在之后被改变了某些内容，但是也会使用<code>预先绑定（pre-bound）的值</code>，该值是对旧的 user 对象的引用。</p>
<h4 id="2-偏函数（Partial-function）"><a href="#2-偏函数（Partial-function）" class="headerlink" title="2. 偏函数（Partial function）"></a>2. 偏函数（Partial function）</h4><pre><code class="hljs js"><span class="hljs-comment">// 完整版</span>
<span class="hljs-keyword">let</span> bound = func.<span class="hljs-title function_">bind</span>(context, [arg1], [arg2], ...);</code></pre>

<p>上面的讨论中，我们只是简单的进行绑定 <code>this</code>，在bind中实际上还可以进行参数的绑定。</p>
<pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mul</span>(<span class="hljs-params">a, b</span>) &#123;
    <span class="hljs-keyword">return</span> a * b;
&#125;

<span class="hljs-keyword">let</span> double = mul.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">2</span>);

<span class="hljs-title function_">alert</span>( <span class="hljs-title function_">double</span>(<span class="hljs-number">3</span>) ); <span class="hljs-comment">// = mul(2, 3) = 6</span></code></pre>

<p>它被称为 <code>偏函数应用程序（partial function application）</code> —— 我们通过绑定先有函数的一些参数来创建一个新函数。</p>
<p>通常我们在一个非常通用的函数中，某个参数总是重复的传入，这个时候偏函数非常有用。</p>
<h2 id="6-对象属性配置"><a href="#6-对象属性配置" class="headerlink" title="6. 对象属性配置"></a>6. 对象属性配置</h2><h3 id="6-1-属性标志"><a href="#6-1-属性标志" class="headerlink" title="6.1 属性标志"></a>6.1 属性标志</h3><h4 id="1-属性标志"><a href="#1-属性标志" class="headerlink" title="1.  属性标志"></a>1.  属性标志</h4><ul>
<li><code>writable</code> — 如果为 <code>true</code>，则值可以被修改，否则它是只可读的。严格模式下修改会抛出异常。</li>
<li><code>enumerable</code> — 如果为 <code>true</code>，则会被在循环中列出，否则不会被列出。</li>
<li><code>configurable</code> — 如果为 <code>true</code>，则此特性可以被删除，这些属性也可以被修改，否则不可以。</li>
</ul>
<p>这些内容通常是被隐藏的，并且值为 <code>true</code> 。</p>
<p><strong>查询某个属性的值及其属性标志值</strong>： <code>getOwnPropertyDescriptor</code></p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> descriptor = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(obj, propertyName);</code></pre>

<p><strong>修改属性</strong>：<code>defineProperty</code></p>
<pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, propertyName, descriptor)</code></pre>

<p>如果该属性存在，<code>defineProperty</code> 会更新其标志。否则，它会使用给定的值和标志创建属性；在这种情况下，如果没有提供标志，则会假定它是 <code>false</code>。</p>
<blockquote>
<p><code>configurable</code> 被设置为false时，我们也不能通过 <code>defineProperty</code> 在对属性做出修改。</p>
</blockquote>
<p><strong>defineProperties 一次性修改多个属性</strong>：</p>
<pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(user, &#123;
    <span class="hljs-attr">name</span>: &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span> &#125;,
    <span class="hljs-attr">surname</span>: &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;Smith&quot;</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span> &#125;,
    <span class="hljs-comment">// ...</span>
&#125;);</code></pre>

<p><strong>getOwnPropertyDescriptors(obj) 一次性获取多个属性描述符</strong></p>
<blockquote>
<p>通常，我们使用循环赋值时进行对象克隆，这种克隆方式通常不会克隆对象的标志。</p>
</blockquote>
<h4 id="2-设定一个全局的密封对象"><a href="#2-设定一个全局的密封对象" class="headerlink" title="2. 设定一个全局的密封对象"></a>2. 设定一个全局的密封对象</h4><p>属性描述符只是限制单个属性，还有一些限制访问整个对象的方法：</p>
<ul>
<li><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions">Object.preventExtensions(obj)</a></p>
<p>禁止向对象添加新属性。</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/seal">Object.seal(obj)</a></p>
<p>禁止添加/删除属性。为所有现有的属性设置 <code>configurable: false</code>。</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze">Object.freeze(obj)</a></p>
<p>禁止添加/删除/更改属性。为所有现有的属性设置 <code>configurable: false, writable: false</code>。</p>
</li>
</ul>
<p>还有针对它们的测试：</p>
<ul>
<li><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible">Object.isExtensible(obj)</a></p>
<p>如果添加属性被禁止，则返回 <code>false</code>，否则返回 <code>true</code>。</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed">Object.isSealed(obj)</a></p>
<p>如果添加/删除属性被禁止，并且所有现有的属性都具有 <code>configurable: false</code>则返回 <code>true</code>。</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen">Object.isFrozen(obj)</a></p>
<p>如果添加/删除/更改属性被禁止，并且所有当前属性都是 <code>configurable: false, writable: false</code>，则返回 <code>true</code>。</p>
</li>
</ul>
<h3 id="6-2-getter和setter"><a href="#6-2-getter和setter" class="headerlink" title="6.2 getter和setter"></a>6.2 getter和setter</h3><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;
    <span class="hljs-keyword">get</span> <span class="hljs-title function_">propName</span>() &#123;
        <span class="hljs-comment">// 当读取 obj.propName 时，getter 起作用</span>
    &#125;,

    <span class="hljs-keyword">set</span> <span class="hljs-title function_">propName</span>(<span class="hljs-params">value</span>) &#123;
        <span class="hljs-comment">// 当执行 obj.propName = value 操作时，setter 起作用</span>
    &#125;
&#125;;</code></pre>

<h4 id="1-访问器"><a href="#1-访问器" class="headerlink" title="1.  访问器"></a>1.  访问器</h4><p>所以访问器描述符可能有：</p>
<ul>
<li><code>get</code> —— 一个没有参数的函数，在读取属性时工作，</li>
<li><code>set</code> —— 带有一个参数的函数，当属性被设置时调用，</li>
<li><code>enumerable</code> —— 与数据属性的相同，</li>
<li><code>configurable</code> —— 与数据属性的相同。</li>
</ul>
<p>请注意，一个属性要么是访问器（具有 <code>get/set</code> 方法），要么是数据属性（具有 <code>value</code>），但不能两者都是。</p>
<pre><code class="hljs js"><span class="hljs-comment">// Error: Invalid property descriptor.</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(&#123;&#125;, <span class="hljs-string">&#x27;prop&#x27;</span>, &#123;
    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
    &#125;,

    <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>
&#125;);</code></pre>

<h4 id="2-属性控制"><a href="#2-属性控制" class="headerlink" title="2. 属性控制"></a>2. 属性控制</h4><p>通过getter/setter，我们可以创建一个”属性“，它比原始的属性更加的灵活。</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> user = &#123;
    <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>() &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_name</span>;
    &#125;,

    <span class="hljs-comment">// 限制name的长度</span>
    <span class="hljs-keyword">set</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">value</span>) &#123;
        <span class="hljs-keyword">if</span> (value.<span class="hljs-property">length</span> &lt; <span class="hljs-number">4</span>) &#123;
            <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Name is too short, need at least 4 characters&quot;</span>);
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_name</span> = value;
    &#125;
&#125;;</code></pre>

<p>尽管我们可以通过 <code>_name</code> 访问 name，但是我们约定以下划线开头的属性为内部属性，不应该从对象外部进行访问。</p>
<h2 id="7-原型，继承"><a href="#7-原型，继承" class="headerlink" title="7. 原型，继承"></a>7. 原型，继承</h2><h3 id="7-1-proto"><a href="#7-1-proto" class="headerlink" title="7.1. proto"></a>7.1. proto</h3><h4 id="1-Prototype"><a href="#1-Prototype" class="headerlink" title="1. [[Prototype]]"></a>1. [[Prototype]]</h4><p>在 JavaScript 中，对象有一个特殊的隐藏属性 <code>[[Prototype]]</code>，它要么为 <code>null</code>，要么就是对另一个对象的引用。该对象被称为“原型”。</p>
<p>我们可以通过设置对象的 <code>_proto_</code> 属性可以完成对象之间的继承：</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> animal = &#123;
    <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span>
&#125;;
<span class="hljs-keyword">let</span> rabbit = &#123;
    <span class="hljs-attr">jumps</span>: <span class="hljs-literal">true</span>
&#125;;

rabbit.<span class="hljs-property">__proto__</span> = animal; <span class="hljs-comment">// 设置 rabbit.[[Prototype]] = animal</span></code></pre>

<p>当我们读取对象中的某一个属性时，如果找不到它就会顺着 <code>继承链(原型链)</code> 向上寻找。从上面可以观察得到JS的继承是一种单继承。</p>
<blockquote>
<p><code>__proto__</code> <strong>是</strong> <code>[[Prototype]]</code> <strong>的因历史原因而留下来的 getter/setter</strong>，<code>__proto__</code> 给对象访问原型，<code>.prototype</code> 给方法访问原型。</p>
</blockquote>
<blockquote>
<p>原型继承是包含访问器的继承</p>
</blockquote>
<h4 id="2-”this“指向"><a href="#2-”this“指向" class="headerlink" title="2. ”this“指向"></a>2. ”this“指向</h4><blockquote>
<p>无论在哪里找到方法：在一个对象还是在原型中。在一个方法调用中，this 始终是点符号 . 前面的对象。所以，方法是共享的，但对象状态不是。</p>
</blockquote>
<h4 id="3-属性迭代"><a href="#3-属性迭代" class="headerlink" title="3. 属性迭代"></a>3. 属性迭代</h4><p><strong>Object.keys</strong>：只返回自己的属性。</p>
<p><strong>for in</strong>：会遍历自己以及继承的键。</p>
<p>**obj.hasOwnProperty(key)**：判断该属性是否只属于自己（不包括继承的）。</p>
<h3 id="7-2-F-prototype"><a href="#7-2-F-prototype" class="headerlink" title="7.2. F.prototype"></a>7.2. F.prototype</h3><p>曾经我们讲过可以使用构造函数的形式创建一个对象。</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> animal = &#123;
    <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span>
&#125;;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Rabbit</span>(<span class="hljs-params">name</span>) &#123;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
&#125;

<span class="hljs-title class_">Rabbit</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = animal;

<span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rabbit</span>(<span class="hljs-string">&quot;White Rabbit&quot;</span>); <span class="hljs-comment">//  rabbit.__proto__ == animal</span>

<span class="hljs-title function_">alert</span>( rabbit.<span class="hljs-property">eats</span> ); <span class="hljs-comment">// true</span></code></pre>

<p>使用这种形式相当于只是为类 Rabbit 创建了一个名为 <code>prototype</code> 的属性，它会在变成对象的那一刻起，该对象的 <code>[[Prototype]]</code> 才被创建。</p>
<p><img src="https://i.loli.net/2021/07/22/LNx7yePqWMQRlJT.png" alt="image-20210722093113166"></p>
<p>在上图中，<code>&quot;prototype&quot;</code> 是一个水平箭头，表示一个常规属性，<code>[[Prototype]]</code> 是垂直的，表示 <code>rabbit</code> 继承自 <code>animal</code>。</p>
<hr>
<p>每个函数都有一个默认的F.prototype属性，即使我们从来没有提供过，该属性的指向是一个只有 <code>constructor</code> 属性的对象，而该属性又指向函数本身。</p>
<p><img src="https://i.loli.net/2021/07/22/8a16zBPFm3jVHfX.png" alt="image-20210722093620300"></p>
<p>由于constructor指向函数本身，所以也可以使用 constructor 进行对象的创建。</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> rabbit2 = <span class="hljs-keyword">new</span> rabbit.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-string">&quot;Black Rabbit&quot;</span></span>);</code></pre>

<blockquote>
<p>JS自身并不能保证 <code>constructor</code> 的正确性，我们甚至可以更改该方法。</p>
</blockquote>
<blockquote>
<p>请注意在 <code>Object.prototype</code> 上方的链中没有更多的 <code>[[Prototype]]</code></p>
</blockquote>
<pre><code class="hljs js"><span class="hljs-title function_">alert</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span>); <span class="hljs-comment">// null</span></code></pre>

<p>对于基本数据类型，尽管印象中它们不属于对象，但是我们真正创建的时候，它会通过相应的临时包装器的构造器创建，大多数引擎都是对这些进行过优化的。</p>
<blockquote>
<p><code>null</code> 和 <code>undefined</code> 没有对象包装器，没有原型，没有属性方法。</p>
</blockquote>
<blockquote>
<p>原型可以更改，但是我们十分不建议，因为这会造成一种污染。</p>
</blockquote>
<p>只有一种情况下我们允许修改原生原型，那就是 <code>polyfilling</code> 。</p>
<p>Polyfilling 是一个术语，表示某个方法在 JavaScript 规范中已存在，但是特定的 JavaScript 引擎尚不支持该方法，那么我们可以通过手动实现它，并用以填充内建原型。</p>
<blockquote>
<p> 注意，原型方法中没有 <strong>proto</strong> 的对象</p>
</blockquote>
<h4 id="1-从原型中进行方法借用"><a href="#1-从原型中进行方法借用" class="headerlink" title="1. 从原型中进行方法借用"></a>1. 从原型中进行方法借用</h4><p>原型方法借用是指，我们从原型中借用一些方法。</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;
    <span class="hljs-number">0</span>: <span class="hljs-string">&quot;Hello&quot;</span>,
    <span class="hljs-number">1</span>: <span class="hljs-string">&quot;world!&quot;</span>,
    <span class="hljs-attr">length</span>: <span class="hljs-number">2</span>,
&#125;;

obj.<span class="hljs-property">join</span> = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">join</span>;

<span class="hljs-title function_">alert</span>( obj.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;,&#x27;</span>) ); <span class="hljs-comment">// Hello,world!</span></code></pre>

<p>上面这段代码有效，是因为内建的方法 <code>join</code> 的内部算法只关心正确的索引和 <code>length</code> 属性。它不会检查这个对象是否是真正的数组。许多内建方法就是这样。</p>
<h4 id="2-原型其它"><a href="#2-原型其它" class="headerlink" title="2. 原型其它"></a>2. 原型其它</h4><p><code>__proto__</code> 被认为是过时且不推荐使用的（deprecated），这里的不推荐使用是指 JavaScript 规范中规定，<strong>proto</strong> 必须仅在浏览器环境下才能得到支持。</p>
<p>现代的方法有：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/create">Object.create(proto, descriptors])</a> —— 利用给定的 <code>proto</code> 作为 <code>[[Prototype]]</code> 和可选的属性描述来创建一个空对象。</li>
<li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf">Object.getPrototypeOf(obj)</a> —— 返回对象 <code>obj</code> 的 <code>[[Prototype]]</code>。</li>
<li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf">Object.setPrototypeOf(obj, proto)</a> —— 将对象 <code>obj</code> 的 <code>[[Prototype]]</code> 设置为 <code>proto</code>。</li>
</ul>
<p>通过以上的方法我们可以完成对象的 <code>超级深克隆</code> ，即克隆对象的属性标志和属性描述符：</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> clone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj), <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>(obj));</code></pre>

<blockquote>
<p>更改原型将会非常的影响执行速度，更改原型本身是一个非常缓慢的操作，因为它破坏了对象属性访问操作的内部优化。</p>
</blockquote>
<blockquote>
<p>我们是无法将对象的 _<em>proto</em>_  的值赋予为字符串</p>
</blockquote>
<h2 id="8-类"><a href="#8-类" class="headerlink" title="8. 类"></a>8. 类</h2><h3 id="8-1-基本语法"><a href="#8-1-基本语法" class="headerlink" title="8.1. 基本语法"></a>8.1. 基本语法</h3><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;
    <span class="hljs-comment">// class 方法</span>
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123; ... &#125;
    <span class="hljs-title function_">method1</span>(<span class="hljs-params"></span>) &#123; ... &#125;
        ...
&#125;</code></pre>

<blockquote>
<p>注意类的方法之间没有逗号</p>
</blockquote>
<p>在JS中类就是一个函数：</p>
<pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123; <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; &#125;
    <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); &#125;
&#125;

<span class="hljs-comment">// 佐证：User 是一个函数</span>
<span class="hljs-title function_">alert</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">User</span>); <span class="hljs-comment">// function</span></code></pre>

<p>类的原型中才真正存储着类的构造器和定义的方法。所以有人将 <code>class</code> 视为一种定义构造器及其原型方法的语法糖。但是它们之间仍然存在着重大差异：</p>
<ul>
<li>通过 <code>class</code> 创建的函数具有特殊的内部属性标记 <code>[[IsClassConstructor]]: true</code>，我们输出该类，和普通方法不同的是它会在前面加一个class。</li>
<li>类中的方法不可枚举。可以修改对应的属性标志使其可以迭代。</li>
<li>类中使用 <code>user strict</code> 类的方法里面的所有代码都会自动进入严格模式。</li>
</ul>
<p>类与函数十分的类似，可以像函数一样在另外一个表达式中被定义，被传递，被返回，被赋值等。</p>
<p>但是一旦类表达式有名字（如上例的User），该名字仅在类内部可见。</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> test=<span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>&#123;&#125;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test); <span class="hljs-comment">// 正常输出</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">User</span>); <span class="hljs-comment">// error</span></code></pre>

<p>就像对象字面量，类可能包括 getters/setters，计算属性（computed properties）等。</p>
<p><code>对于类的字段，只需要使用 ”=“进行设置，和类的方法不同之处在于，它就存在于被创建的对象中，而不是对象的原型中。</code></p>
<p>正如方法容易丢失<code> ”this“</code>一样，类也会丢失”this“。</p>
<p>在前面我们讲过一些方法，比如：</p>
<ol>
<li>传递一个包装函数，例如 <code>setTimeout(() =&gt; button.click(), 1000)</code>。</li>
<li>将方法绑定到对象，例如在 constructor 中。</li>
</ol>
<p>但是在类中我们可以使用更加优雅的方式：</p>
<pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Button</span> &#123;
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;
    &#125;
    click = <span class="hljs-function">() =&gt;</span> &#123;
        <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);
    &#125;
&#125;

<span class="hljs-keyword">let</span> button = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;hello&quot;</span>);

<span class="hljs-built_in">setTimeout</span>(button.<span class="hljs-property">click</span>, <span class="hljs-number">1000</span>); <span class="hljs-comment">// hello</span></code></pre>

<h3 id="8-2-类继承（extends）"><a href="#8-2-类继承（extends）" class="headerlink" title="8.2. 类继承（extends）"></a>8.2. 类继承（extends）</h3><p>extends关键字后面不仅仅可以跟类名，还可以跟任意表达式。</p>
<pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">phrase</span>) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> &#123;
        <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-title function_">alert</span>(phrase); &#125;
    &#125;;
&#125;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">f</span>(<span class="hljs-string">&quot;Hello&quot;</span>) &#123;&#125;

<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>().<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// Hello</span></code></pre>

<p>类中使用 <code>super</code> 进行调用父类的方法，同时，箭头函数没有super。</p>
<p>根据规范，如果一个类没有显式的定义 <code>constructor</code> ，那么该方法就会默认的创建</p>
<pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rabbit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;
    <span class="hljs-comment">// 为没有自己的 constructor 的扩展类生成的</span>
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">...args</span>) &#123;
        <span class="hljs-variable language_">super</span>(...args);
    &#125;
&#125;</code></pre>

<p>和Java类似，在子类中，如果构造函数中使用 <code>this</code> 那么它必须在此之前调用super。</p>
<p>子父类之间从重载不仅可以发生在函数上，还可以发生在字段之中。但是父类的构造器总是使用父类的字段不会使用子类的字段，这是因为在子类初始化完全之前即构造函数调用时，它会首先调用父类的构造方法以完成父类的初始化，<code>所以父类才会调用父类的字段，因为子类还没有完成初始化</code>。</p>
<p>这个与函数是不同的，函数尽管没有完成子类的初始化，但是仍然会进行调用子类的函数。</p>
<h4 id="深入探究Super"><a href="#深入探究Super" class="headerlink" title="深入探究Super"></a>深入探究Super</h4><p>// TODO</p>
<h3 id="8-3-静态属性和静态方法"><a href="#8-3-静态属性和静态方法" class="headerlink" title="8.3 静态属性和静态方法"></a>8.3 静态属性和静态方法</h3><p><code>静态属性和静态方法不是存放在类的原型上的而是放在类本身上。</code>这样的属性和方法我们使用static进行修饰。我们可以直接使用”<code>className.method/filed</code>“的操作直接访问或者修改。</p>
<pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;
    <span class="hljs-keyword">static</span> <span class="hljs-title function_">staticMethod</span>(<span class="hljs-params"></span>) &#123;
        <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span> === <span class="hljs-title class_">User</span>);
    &#125;
&#125;

<span class="hljs-title class_">User</span>.<span class="hljs-title function_">staticMethod</span>(); <span class="hljs-comment">// true</span></code></pre>

<blockquote>
<p>静态属性和方法是被继承的。</p>
</blockquote>
<h3 id="8-4-私有的和受保护的属性和方法"><a href="#8-4-私有的和受保护的属性和方法" class="headerlink" title="8.4 私有的和受保护的属性和方法"></a>8.4 私有的和受保护的属性和方法</h3><p>一个约定俗称的就是在受保护的属性以下划线开始，然后使用getter/setter进行限制，但是这并不是语言级别的强制实施。</p>
<p>如果真正做到私有属性则使用”<code>#</code>“开始作为命名。所以”#name“和”name“完全是两个字段或函数，我们可以在同一个类中进行使用。</p>
<h3 id="8-5-内建类"><a href="#8-5-内建类" class="headerlink" title="8.5 内建类"></a>8.5 内建类</h3><p>通过继承的方式进行内建类的扩展，有意思的是有些内建的方法如 <code>filter</code>，<code>map</code> 等 — 返回的对象是通过 <code>constructor </code> 进行构建的而不是直接使用原生的Array，这回有一个很有意思的结果，如果我们创建一个数组的子类，在子类中使用map等函数那么它返回的对象就是子类。</p>
<p><strong>Symbol.species</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PowerArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Array</span> &#123;
    <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>;
    &#125;

    <span class="hljs-comment">// 内建方法将使用这个作为 constructor</span>
    <span class="hljs-keyword">static</span> get [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">species</span>]() &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>;
    &#125;
&#125;</code></pre>

<p><strong>内建类没有静态方法继承</strong>：</p>
<ul>
<li>当通过extends继承的时候，静态方法和非静态方法都会被继承</li>
<li>当没有写extends，默认继承object，此时只有非静态方法会被继承</li>
</ul>
<blockquote>
<p>内建类都是使用的默认继承，所以不继承静态方法。</p>
</blockquote>
<h3 id="8-6-类检查"><a href="#8-6-类检查" class="headerlink" title="8.6 类检查"></a>8.6 类检查</h3><h4 id="1-instanceof"><a href="#1-instanceof" class="headerlink" title="1. instanceof"></a>1. instanceof</h4><pre><code class="hljs js">obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Class</span></code></pre>

<p>如果 <code>obj</code> 隶属于 <code>Class</code> 类（或 <code>Class</code> 类的衍生类），则返回 <code>true</code>。</p>
<p>使用 <code>Symbol.hasInstance</code> 可以自定义instanceof的判断逻辑。</p>
<pre><code class="hljs js"><span class="hljs-comment">// 设置 instanceOf 检查</span>
<span class="hljs-comment">// 并假设具有 canEat 属性的都是 animal</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;
    <span class="hljs-keyword">static</span> [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">hasInstance</span>](obj) &#123;
        <span class="hljs-keyword">if</span> (obj.<span class="hljs-property">canEat</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;
&#125;</code></pre>

<p>大多数 class 没有 <code>Symbol.hasInstance</code>。在这种情况下，标准的逻辑是：使用 <code>obj instanceOf Class</code> 检查 <code>Class.prototype</code> 是否等于 <code>obj</code> 的原型链中的原型之一。即逐层比较原型链看是否有相等的类。</p>
<p>与 <code>instanceof</code> 类似的方法是 <code>objA.isPrototypeOf(objB)</code> ，这个方法中如果 <code>objA</code> 处在 <code>objB</code> 的原型链中，则返回 <code>true</code>。</p>
<p>注意在上面的两个方法中，类的构造函数是不会参与比较的，这也就意味着：</p>
<pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Rabbit</span>(<span class="hljs-params"></span>) &#123;&#125;
<span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rabbit</span>();

<span class="hljs-comment">// 修改了 prototype</span>
<span class="hljs-title class_">Rabbit</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;&#125;;

<span class="hljs-comment">// ...再也不是 rabbit 了！</span>
<span class="hljs-title function_">alert</span>( rabbit <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Rabbit</span> ); <span class="hljs-comment">// false</span></code></pre>

<h4 id="2-toString"><a href="#2-toString" class="headerlink" title="2. toString"></a>2. toString</h4><p><strong>使用Object.prototype.toString来揭示类型</strong></p>
<p>由于部分内建类对Object的toString方法进行重写过，所以我们可以使用 <code>func.call</code> 来进行借用。</p>
<pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>([])); <span class="hljs-comment">// [object Array]</span></code></pre>

<h4 id="3-Symbol-toStringTag"><a href="#3-Symbol-toStringTag" class="headerlink" title="3. Symbol.toStringTag"></a>3. Symbol.toStringTag</h4><p>可以使用特殊的对象属性 <code>Symbol.toStringTag</code> 自定义对象的 <code>toString</code> 方法的行为。</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> user = &#123;
    [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>]: <span class="hljs-string">&quot;User&quot;</span>
&#125;;

<span class="hljs-title function_">alert</span>( &#123;&#125;.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(user) ); <span class="hljs-comment">// [object User]</span></code></pre>

<blockquote>
<p>注意，只能在对象上使用。</p>
</blockquote>
<h3 id="8-7-Mixin模式"><a href="#8-7-Mixin模式" class="headerlink" title="8.7 Mixin模式"></a>8.7 Mixin模式</h3><p>根据维基百科的定义，<a href="https://en.wikipedia.org/wiki/Mixin">mixin</a> 是一个包含可被其他类使用而无需继承的方法的类。</p>
<p>在js中其实现原理就是使用js提供的拷贝方法。</p>
<pre><code class="hljs js"><span class="hljs-comment">// mixin</span>
<span class="hljs-keyword">let</span> sayHiMixin = &#123;
    <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;
        <span class="hljs-title function_">alert</span>(<span class="hljs-string">`Hello <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);
    &#125;,
&#125;;

<span class="hljs-comment">// 用法：</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    &#125;
&#125;

<span class="hljs-comment">// 拷贝方法</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">User</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, sayHiMixin);

<span class="hljs-comment">// 现在 User 可以打招呼了</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Dude&quot;</span>).<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// Hello Dude!</span></code></pre>

<p>// TODO</p>
<h2 id="9-错误处理"><a href="#9-错误处理" class="headerlink" title="9. 错误处理"></a>9. 错误处理</h2><h3 id="9-1-try-catch"><a href="#9-1-try-catch" class="headerlink" title="9.1. try..catch"></a>9.1. try..catch</h3><p>注意catch中能捕获的错误仅包含运行时error。这类错误被称为“运行时的错误（runtime errors）”，有时被称为“异常（exceptions）”。</p>
<blockquote>
<p>try..catch仅能捕获 <code>&quot;计划的（scheduled）”</code>代码中发生异常，如果在异步中或者定时器中出现错误代码将无法捕获。</p>
</blockquote>
<h4 id="1-Error对象"><a href="#1-Error对象" class="headerlink" title="1. Error对象"></a>1. Error对象</h4><p>当错误发生时，JavaScript 生成一个包含有关其详细信息的对象。然后将该对象作为参数传递给 <code>catch</code>，</p>
<p>Error对象主要有三个属性：</p>
<ul>
<li><p><code>name</code>：Error 名称。例如，对于一个未定义的变量，名称是 <code>&quot;ReferenceError&quot;</code>。</p>
</li>
<li><p><code>message</code>：关于 error 的详细文字描述。还有其他非标准的属性在大多数环境中可用。其中被最广泛使用和支持的是：</p>
</li>
<li><p><code>stack</code>：当前的调用栈：用于调试目的的一个字符串，其中包含有关导致 error 的嵌套调用序列的信息。</p>
</li>
</ul>
<p>如果不需要Error对象，那么可以不进行参数传入。</p>
<h4 id="2-Throw"><a href="#2-Throw" class="headerlink" title="2. Throw"></a>2. Throw</h4><p><code>throw</code> 操作符会生成一个 error 对象。理论上任何东西都可以作为一个 Error 对象，甚至是基本数据类型，但最好使用对象，最好使用具有 <code>name</code> 和 <code>message</code> 属性的对象（某种程度上保持与内建 error 的兼容性）。</p>
<p>JavaScript 中有很多内建的标准 error 的构造器：<code>Error</code>，<code>SyntaxError</code>，<code>ReferenceError</code>，<code>TypeError</code> 等。我们也可以使用它们来创建 error 对象。</p>
<h4 id="3-再次抛出"><a href="#3-再次抛出" class="headerlink" title="3. 再次抛出"></a>3. 再次抛出</h4><p>由于在try中发生的所有错误，我们都会被catch接收到，但是接受到的这个错误可能会含有一些我们意料之外的错误，这个时候我们通过 instanceof 进行判断，如果不是意料之中的错误，那么就进行再次抛出，即在catch 中重复使用 throw。</p>
<pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">readData</span>(<span class="hljs-params"></span>) &#123;
    <span class="hljs-keyword">let</span> json = <span class="hljs-string">&#x27;&#123; &quot;age&quot;: 30 &#125;&#x27;</span>;

    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-comment">// ...</span>
        <span class="hljs-title function_">blabla</span>(); <span class="hljs-comment">// error!</span>
    &#125; <span class="hljs-keyword">catch</span> (e) &#123;
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">if</span> (!(e <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">SyntaxError</span>)) &#123;
            <span class="hljs-keyword">throw</span> e; <span class="hljs-comment">// 再次抛出（不知道如何处理它）</span>
        &#125;
    &#125;
&#125;

<span class="hljs-keyword">try</span> &#123;
    <span class="hljs-title function_">readData</span>();
&#125; <span class="hljs-keyword">catch</span> (e) &#123;
    <span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;External catch got: &quot;</span> + e ); <span class="hljs-comment">// 捕获了它！</span>
&#125;</code></pre>

<h4 id="3-finally"><a href="#3-finally" class="headerlink" title="3. finally"></a>3. finally</h4><p>finally里面的代码无论是否错误都是会被执行的。</p>
<blockquote>
<p>注意 try catch finally三个代码块中的代码的作用域是相互隔离的</p>
</blockquote>
<blockquote>
<p>catch 和 finally 两者只能省略一个</p>
</blockquote>
<hr>
<p>正如人生一样，我们总是无法去预测所有意外，如果仅仅因为某一个未知的意外从而导致整个程序的死亡，那是不是未免太过于不值得了。</p>
<p>尽管规范中没有相关内容，但是代码的执行环境一般会提供这种机制，因为它确实很有用。但是在某些运行环境中会提供相关方法来进行捕获那些未知的意外，在浏览器中，我们可以将将一个函数赋值给特殊的 <a href="https://developer.mozilla.org/zh/docs/Web/API/GlobalEventHandlers/onerror">window.onerror</a> 属性，该函数将在发生未捕获的 error 时执行。</p>
<pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">message, url, line, col, error</span>) &#123;
    <span class="hljs-comment">// ...</span>
&#125;;</code></pre>

<ul>
<li><code>message</code>：Error信息</li>
<li><code>url</code>：发生 error 的脚本的 URL。</li>
<li><pre><code>`line`，`col`：发生 error 处的代码的行号和列号。
</code></pre>
</li>
<li><pre><code>`error`：Error 对象。
</code></pre>
</li>
</ul>
<p>全局错误处理程序 <code>window.onerror</code> 的作用通常不是恢复脚本的执行 — 如果发生编程错误，那这几乎是不可能的（因为拿着个错误的结果继续执行也没有意义），它的作用是将错误信息发送给开发者。</p>
<h3 id="9-2-Error扩展"><a href="#9-2-Error扩展" class="headerlink" title="9.2 Error扩展"></a>9.2 Error扩展</h3><p>通过对内建类的继承以完成Error扩展</p>
<pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ValidationError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Error</span> &#123;
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">message</span>) &#123;
        <span class="hljs-variable language_">super</span>(message);
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span>.<span class="hljs-property">name</span>; <span class="hljs-comment">// ValidationError</span>
    &#125;
&#125;</code></pre>

<p>我们在使用时也应该像再次抛出中一样，多次判断并最终抛出到外层。</p>
<h4 id="包装异常"><a href="#包装异常" class="headerlink" title="包装异常"></a>包装异常</h4><p>当我们的异常量增加的时候，如果每个都需要用if进行判断那是否未免有点过于麻烦了。</p>
<p>我们可以在抛出时处理，即无论什么异常统一进行二次抛出，并抛出同一个异常。这样进行接受时只需要进行处理一次。</p>
<h2 id="10-Promise-async-await"><a href="#10-Promise-async-await" class="headerlink" title="10 Promise, async/await"></a>10 Promise, async/await</h2><h3 id="10-1-回调"><a href="#10-1-回调" class="headerlink" title="10.1 回调"></a>10.1 回调</h3><p>所谓回调就是当函数执行完毕之后会进行执行另一段代码，我们通常的做法是，将回调函数作为参数传入给函数，再在函数最后一句执行传入的函数：</p>
<pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">back</span>)&#123;
    <span class="hljs-comment">// ... 执行任务</span>
    <span class="hljs-comment">// ... 执行完毕</span>
    <span class="hljs-title function_">back</span>()
&#125;

<span class="hljs-title function_">callback</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;test&#x27;</span>);
&#125;); <span class="hljs-comment">// test</span></code></pre>

<p>如果我们需要等第一个执行完，再执行第二个，第二个执行完再执行第三个….，我们就需要在回调中继续回调…，这就造成了 <code>厄运金字塔(回调地狱)</code>，即内部不断的嵌套。</p>
<p><img src="https://i.loli.net/2021/07/22/I5YdScRHbgPZQAm.png" alt="image-20210722171331149"></p>
<p>但是我们可以各个函数都设计成顶层函数：</p>
<pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;
  <span class="hljs-title function_">step1</span>();
  <span class="hljs-title function_">step2</span>();
  <span class="hljs-title function_">step3</span>();
  ...
&#125;</code></pre>

<p>但是这很不方便，特别是如果读者对代码不熟悉，他们甚至不知道应该跳转到什么地方。</p>
<p>此外，名为 <code>step*</code> 的函数都是一次性使用的，创建它们就是为了避免“厄运金字塔”。没有人会在行为链之外重用它们。因此，这里的命名空间有点混乱。</p>
<h4 id="1-Promise"><a href="#1-Promise" class="headerlink" title="1. Promise"></a>1. Promise</h4><p><code>Promise</code> 对象的构造器（constructor）语法如下：</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;
  <span class="hljs-comment">// executor（生产者代码，“歌手”）</span>
&#125;);</code></pre>

<p>传递给Promise的函数被称为 <code>executor</code>。</p>
<p>它的参数 <code>resolve</code> 和 <code>reject</code> 是由 JavaScript 自身提供的回调。我们的代码仅在 executor 的内部。</p>
<ul>
<li><code>resolve(value)</code> — 如果任务成功完成并带有结果 <code>value</code>。</li>
<li><code>reject(error)</code> — 如果出现了 error，<code>error</code> 即为 error 对象，可以不传入error对象，但是建议不这样。</li>
</ul>
<p>由 <code>new Promise</code> 构造器返回的 <code>promise</code> 对象具有以下内部属性：</p>
<ul>
<li><code>state</code> — 最初是 <code>&quot;pending&quot;</code>，然后在 <code>resolve</code> 被调用时变为 <code>&quot;fulfilled&quot;</code>，或者在 <code>reject</code> 被调用时变为 <code>&quot;rejected&quot;</code>。</li>
<li><code>result</code> — 最初是 <code>undefined</code>，然后在 <code>resolve(value)</code> 被调用时变为 <code>value</code>，或者在 <code>reject(error)</code> 被调用时变为 <code>error</code>。</li>
</ul>
<blockquote>
<p>executor，只能调用一个函数，如果首先调用了resolve，接下来又调用reject，那么reject将会被忽略。</p>
</blockquote>
<h4 id="2-then-catch-finally"><a href="#2-then-catch-finally" class="headerlink" title="2. then, catch, finally"></a>2. then, catch, finally</h4><h5 id="1-then"><a href="#1-then" class="headerlink" title="1. then"></a>1. then</h5><p><code>.then</code>接受两个函数作为参数，即当promise得到结果后，第一个参数为成功的回调函数，第二个参数为失败的回调函数。如果我们只对成功的结果感兴趣，那么可以只传入成功的回调函数。</p>
<h5 id="2-catch"><a href="#2-catch" class="headerlink" title="2. catch"></a>2. catch</h5><p>如果我们只对失败的结果感兴趣，那么可以在 <code>then</code> 中，第一参数为null，第二个为失败的回调函数。这样有点别扭，于是我们提供了 <code>.catch</code>，这两者的结果都是相同的，相当于只是 then的简写形式。</p>
<h5 id="3-finally-1"><a href="#3-finally-1" class="headerlink" title="3. finally"></a>3. finally</h5><p>即promise无论成功还是失败都会被执行的代码。在finally后我们可以将程序结果传递给下一个处理程序。</p>
<pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;
    <span class="hljs-comment">/* 做一些需要时间的事儿，然后调用 resolve/reject */</span>
&#125;)
<span class="hljs-comment">// 在 promise 为 settled 时运行，无论成功与否</span>
    .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> stop loading indicator)
<span class="hljs-comment">// 所以，加载指示器（loading indicator）始终会在我们处理结果/错误之前停止</span>
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> show result, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> show error)</code></pre>

<h3 id="10-2-Promise-链"><a href="#10-2-Promise-链" class="headerlink" title="10.2 Promise 链"></a>10.2 Promise 链</h3><p>promise的结果是在then中接受，但是then或者其它函数返回的结果都仍然是一个promise，then传入的两个函数中返回的结果可以被下一个then所接受，这样一层一层的传递就形成了一个 <code>promise链</code> 。</p>
<pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resove, reject</span>) &#123;
    <span class="hljs-title function_">resove</span>(<span class="hljs-string">&#x27;ok&#x27;</span>)
&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">r</span>=&gt;</span> (r+<span class="hljs-string">&#x27; fine&#x27;</span>)).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">r</span>=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r)) <span class="hljs-comment">//ok fine</span></code></pre>

<p>如果在then中返回的是新的promise，那么then函数的结果就是那个新的promise。</p>
<p>确切地说，处理程序（handler）返回的不完全是一个 promise，而是返回的被称为 <code>“thenable”</code> 对象 。这个 “thenable”对象具有then方法，所以会被当作一个promise处理。在这个自定义的then方法有点类似创建promise传入的executor。</p>
<h3 id="10-3-Promise错误处理"><a href="#10-3-Promise错误处理" class="headerlink" title="10.3 Promise错误处理"></a>10.3 Promise错误处理</h3><p>在Promise链中可以调用多次then，建议将catch放到最后，这样无论前面的哪一个then出错，它都会在最后的catch进行统一处理。</p>
<p>无论是Promise中reject还是编码中的异常，那么这些所有的异常都可以被catch所捕获，这就相当于promise周围被隐式地使用try catch。同理我们可以在catch中进行二次抛出。并且可以使用promise链的下一个then进行处理。</p>
<p>如果promise中进行了reject，并且函数没有catch处理，那么JS引擎将会生成一个全局的error。</p>
<p>由于promise异步执行的特点，如果我们进行捕获错误的时间在promise错误发生之前，即为捕获到，那么promise将会错误。</p>
<h3 id="10-4-Promise-API"><a href="#10-4-Promise-API" class="headerlink" title="10.4 Promise API"></a>10.4 Promise API</h3><h4 id="1-Promise-all"><a href="#1-Promise-all" class="headerlink" title="1. Promise.all"></a>1. Promise.all</h4><pre><code class="hljs js"><span class="hljs-keyword">let</span> promise = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([...promises...]);</code></pre>

<blockquote>
<p>请注意，结果数组中元素的顺序与其在源 promise 中的顺序相同。即使第一个 promise 花费了最长的时间才 resolve，但它仍是结果数组中的第一个。</p>
</blockquote>
<p>一个常见的技巧就是，使用map函数生成promise数组以进行最终处理：</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> names = [<span class="hljs-string">&#x27;iliakan&#x27;</span>, <span class="hljs-string">&#x27;remy&#x27;</span>, <span class="hljs-string">&#x27;jeresig&#x27;</span>];

<span class="hljs-keyword">let</span> requests = names.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`https://api.github.com/users/<span class="hljs-subst">$&#123;name&#125;</span>`</span>));

<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(requests)
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">responses</span> =&gt;</span> &#123;
    <span class="hljs-comment">// 所有响应都被成功 resolved</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> response <span class="hljs-keyword">of</span> responses) &#123;
        <span class="hljs-title function_">alert</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;response.url&#125;</span>: <span class="hljs-subst">$&#123;response.status&#125;</span>`</span>); <span class="hljs-comment">// 对应每个 url 都显示 200</span>
    &#125;

    <span class="hljs-keyword">return</span> responses;
&#125;)
<span class="hljs-comment">// 将响应数组映射（map）到 response.json() 数组中以读取它们的内容</span>
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">responses</span> =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(responses.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.<span class="hljs-title function_">json</span>())))
<span class="hljs-comment">// 所有 JSON 结果都被解析：&quot;users&quot; 是它们的数组</span>
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> users.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> <span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>)));</code></pre>

<p>如果当中的任意一个promise出现了reject，那么被 reject 的 error 成为了整个 <code>Promise.all</code> 的结果，其它的promise将会被忽略。</p>
<blockquote>
<p>通常，<code>Promise.all(...)</code> 接受含有 promise 项的可迭代对象（大多数情况下是数组）作为参数。但是，如果这些对象中的任何一个不是 promise，那么它将被“按原样”传递给结果数组。</p>
</blockquote>
<h4 id="2-Promise-allSettled"><a href="#2-Promise-allSettled" class="headerlink" title="2. Promise.allSettled"></a>2. Promise.allSettled</h4><p><code>Promise.allSettled</code> 等待所有的 promise 都被 settle，无论结果如何。结果数组具有：</p>
<ul>
<li><code>&#123;status:&quot;fulfilled&quot;, value:result&#125;</code> 对于成功的响应，</li>
<li><code>&#123;status:&quot;rejected&quot;, reason:error&#125;</code> 对于 error。</li>
</ul>
<p><strong>Promise.allSettled如果不支持，那么创建它的pilyfill</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Promise</span>.<span class="hljs-property">allSettled</span>) &#123;
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">rejectHandler</span> = reason =&gt; (&#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;rejected&#x27;</span>, reason &#125;);

    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolveHandler</span> = value =&gt; (&#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;fulfilled&#x27;</span>, value &#125;);

    <span class="hljs-title class_">Promise</span>.<span class="hljs-property">allSettled</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) &#123;
        <span class="hljs-keyword">const</span> convertedPromises = promises.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p).<span class="hljs-title function_">then</span>(resolveHandler, rejectHandler));
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(convertedPromises);
    &#125;;
&#125;</code></pre>

<h4 id="3-Promise-race"><a href="#3-Promise-race" class="headerlink" title="3. Promise.race"></a>3. Promise.race</h4><p>等待第一个Promise结果为正常的，就算第一个promise是reject也会忽略。</p>
<h4 id="4-Promise-resolve-reject"><a href="#4-Promise-resolve-reject" class="headerlink" title="4. Promise.resolve/reject"></a>4. Promise.resolve/reject</h4><p>在现代的代码中，很少需要使用 <code>Promise.resolve</code> 和 <code>Promise.reject</code> 方法，因为 <code>async/await</code> 语法（我们会在 <a href="https://zh.javascript.info/async-await">稍后</a> 讲到）使它们变得有些过时了。</p>
<p><code>Promise.resolve(value)</code> 用结果 <code>value</code> 创建一个 resolved 的 promise。</p>
<pre><code class="hljs js"><span class="hljs-comment">// 和这个结果类似</span>
<span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-title function_">resolve</span>(value));</code></pre>

<p><code>Promise.reject(error)</code> 用 <code>error</code> 创建一个 rejected 的 promise。</p>
<pre><code class="hljs js"><span class="hljs-comment">// 和这个结果类似</span>
<span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-title function_">reject</span>(error));</code></pre>

<h3 id="10-5-Promisification"><a href="#10-5-Promisification" class="headerlink" title="10.5 Promisification"></a>10.5 Promisification</h3><p>“Promisification” 是用于一个简单转换的一个长单词。它指将一个接受回调的函数转换为一个返回 promise 的函数。</p>
<pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">promisify</span>(<span class="hljs-params">f</span>) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123; <span class="hljs-comment">// 返回一个包装函数（wrapper-function） (*)</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;
            <span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">err, result</span>) &#123; <span class="hljs-comment">// 我们对 f 的自定义的回调 (**)</span>
                <span class="hljs-keyword">if</span> (err) &#123;
                    <span class="hljs-title function_">reject</span>(err);
                &#125; <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-title function_">resolve</span>(result);
                &#125;
            &#125;

            args.<span class="hljs-title function_">push</span>(callback); <span class="hljs-comment">// 将我们的自定义的回调附加到 f 参数（arguments）的末尾</span>

            f.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, ...args); <span class="hljs-comment">// 调用原始的函数</span>
        &#125;);
    &#125;;
&#125;

<span class="hljs-comment">// 用法：</span>
<span class="hljs-keyword">let</span> loadScriptPromise = <span class="hljs-title function_">promisify</span>(loadScript);
<span class="hljs-comment">// loadScriptPromise(...).then(...);</span></code></pre>

<p>也有一些具有更灵活一点的 promisification 函数的模块（module），例如 <a href="https://github.com/digitaldesignlabs/es6-promisify">es6-promisify</a>。在 Node.js 中，有一个内建的 promisify 函数 <code>util.promisify</code>。</p>
<blockquote>
<p>Promise 处理始终是异步的，因为所有 promise 行为都会通过内部的 “promise jobs” 队列，也被称为“微任务队列”（ES8 术语）。</p>
</blockquote>
<p>如果我们需要将代码执行进行放在proimse结果之后执行，可以将代码放在then中。</p>
<h3 id="10-6-Async-Await"><a href="#10-6-Async-Await" class="headerlink" title="10.6 Async/Await"></a>10.6 Async/Await</h3><h4 id="1-Async-function"><a href="#1-Async-function" class="headerlink" title="1. Async function"></a>1. Async function</h4><p>在函数前面的 “async” 这个单词表达了一个简单的事情：即这个函数总是返回一个 promise。其他值将自动被包装在一个 resolved 的 promise 中。</p>
<h4 id="2-Await"><a href="#2-Await" class="headerlink" title="2. Await"></a>2. Await</h4><p>关键字 <code>await</code> 让 JavaScript 引擎等待直到 promise 完成（settle）并返回结果，他只在 <code>async</code> 函数内部使用。</p>
<p><code>await</code> 实际上会暂停函数的执行，直到 promise 状态变为 settled，然后以 promise 的结果继续执行。这个行为不会耗费任何 CPU 资源，因为 JavaScript 引擎可以同时处理其他任务：执行其他脚本，处理事件等。</p>
<p>相比于 <code>promise.then</code>，它只是获取 promise 的结果的一个更优雅的语法，同时也更易于读写。</p>
<blockquote>
<p>await 不能在顶层使用，这是因为await旨在async函数内部使用，但是从 V8 引擎 8.9+ 版本开始，顶层 await 可以在 <a href="https://zh.javascript.info/modules">模块</a> 中工作。</p>
</blockquote>
<p>像 <code>promise.then</code> 那样，<code>await</code> 允许我们使用 thenable 对象（那些具有可调用的 <code>then</code> 方法的对象）。</p>
<p>如果await等待的结果是一个 error，那么可以使用try catch来接受错误，如果没有处理那么包含await的async函数返回的promise将会包含这个错误。</p>
<p><strong>async/await 可以和 Promise.all 一起使用</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> results = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([
  <span class="hljs-title function_">fetch</span>(url1),
  <span class="hljs-title function_">fetch</span>(url2),
  ...
]);</code></pre>

<p>如果出现 error，也会正常传递，从失败了的 promise 传到 <code>Promise.all</code>，然后变成我们能通过使用 <code>try..catch</code> 在调用周围捕获到的异常（exception）。</p>
<h2 id="11-Generator-高级-iteration"><a href="#11-Generator-高级-iteration" class="headerlink" title="11. Generator, 高级 iteration"></a>11. Generator, 高级 iteration</h2><h3 id="11-1-Generator"><a href="#11-1-Generator" class="headerlink" title="11.1 Generator"></a>11.1 Generator</h3><p>常规函数只会返回一个单一值（或者不返回任何值）。</p>
<p>而 Generator 可以按需一个接一个地返回（“yield”）多个值。它们可与 <a href="https://zh.javascript.info/iterable">iterable</a> 完美配合使用，从而可以轻松地创建数据流。</p>
<h4 id="1-Generator函数"><a href="#1-Generator函数" class="headerlink" title="1. Generator函数"></a>1. Generator函数</h4><pre><code class="hljs js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generateSequence</span>(<span class="hljs-params"></span>) &#123;
    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
&#125;</code></pre>

<p>Generator 函数与常规函数的行为不同。在此类函数被调用时，它不会运行其代码。而是返回一个被称为 “<code>generator object</code>” 的特殊对象，来管理执行流程。</p>
<p>generator 对象当中最重要的方法就是 <code>next()</code>，next执行后会运行到最近的yield为止并返回后面的的数据（像return一样 可返回空[undefined]），return并不是必须的。next的结果始终是一个具有两个属性的对象：</p>
<ul>
<li><code>value</code>: 产出的（yielded）的值。</li>
<li><code>done</code>: 如果 generator 函数已执行完成则为 <code>true</code>，否则为 <code>false</code>。</li>
</ul>
<p>如果执行完之后再进行next那么返回的结果将没有意义，都是一样的对象：<code>&#123;done: true&#125;</code>。</p>
<blockquote>
<p><code>function* f(…)</code> 或 <code>function *f(…)</code> 都可以</p>
</blockquote>
<h4 id="2-迭代Generator"><a href="#2-迭代Generator" class="headerlink" title="2. 迭代Generator"></a>2. 迭代Generator</h4><p>这是因为 <code>Generator</code> 对象含有 <code>next </code>方法。可以使用for of的方式进行迭代，但是 return返回的结果并不会迭代出来，可以将return换成yeild。</p>
<p>正是因为 Generator 的可迭代性，所以我们可以使用解构符将结果直接解构出来</p>
<p><strong>可以使用Generator函数去创建迭代器</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> range = &#123;
    <span class="hljs-attr">from</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">to</span>: <span class="hljs-number">5</span>,

    *[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123; <span class="hljs-comment">// [Symbol.iterator]: function*() 的简写形式</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-property">from</span>; value &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">to</span>; value++) &#123;
            <span class="hljs-keyword">yield</span> value;
        &#125;
    &#125;
&#125;;

<span class="hljs-title function_">alert</span>( [...range] ); <span class="hljs-comment">// 1,2,3,4,5</span></code></pre>

<p>迭代器期望得到的对象正是 Generator 所生成的。</p>
<blockquote>
<p>Generator 可以永远进行产出(yield)，比如我们生成一个无序的随机数序列。</p>
</blockquote>
<h4 id="3-Generator组合"><a href="#3-Generator组合" class="headerlink" title="3. Generator组合"></a>3. Generator组合</h4><p>Generator 组合（composition）是 generator 的一个特殊功能，它允许透明地（transparently）将 generator 彼此“嵌入（embed）”到一起。</p>
<p><code>yield*</code> 指令将执行 <strong>委托</strong> 给另一个 generator。</p>
<h4 id="4-双向的“yield”"><a href="#4-双向的“yield”" class="headerlink" title="4. 双向的“yield”"></a>4. 双向的“yield”</h4><p>事实上，yield可以接受到来自外界的参数（不是在Generator函数中）。</p>
<pre><code class="hljs js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">gen</span>(<span class="hljs-params"></span>) &#123;
    <span class="hljs-keyword">let</span> ask1 = <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;2 + 2 = ?&quot;</span>;

    <span class="hljs-title function_">alert</span>(ask1); <span class="hljs-comment">// 4</span>

    <span class="hljs-keyword">let</span> ask2 = <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;3 * 3 = ?&quot;</span>

    <span class="hljs-title function_">alert</span>(ask2); <span class="hljs-comment">// 9</span>
&#125;

<span class="hljs-keyword">let</span> generator = <span class="hljs-title function_">gen</span>();
<span class="hljs-comment">// 如果在这里传入参数将会被忽略</span>
<span class="hljs-title function_">alert</span>( generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span> ); <span class="hljs-comment">// &quot;2 + 2 = ?&quot;</span>

<span class="hljs-title function_">alert</span>( generator.<span class="hljs-title function_">next</span>(<span class="hljs-number">4</span>).<span class="hljs-property">value</span> ); <span class="hljs-comment">// &quot;3 * 3 = ?&quot;</span>

<span class="hljs-title function_">alert</span>( generator.<span class="hljs-title function_">next</span>(<span class="hljs-number">9</span>).<span class="hljs-property">done</span> ); <span class="hljs-comment">// true</span></code></pre>

<p>既然yield可以传入内容进入那么它也可以在那里发起（抛出）一个 error。这很自然，因为 error 本身也是一种结果。</p>
<pre><code class="hljs js">generator.<span class="hljs-keyword">throw</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Test Error&quot;</span>))</code></pre>

<p>如果在 Generator 函数中使用try catch在相应的yield，那么可以接收到这个错误。</p>
<p>如果我们没有在那里捕获这个 error，那么，通常，它会掉入外部调用代码（如果有），如果在外部也没有被捕获，则会杀死脚本。</p>
<h3 id="11-2-异步迭代和Generator"><a href="#11-2-异步迭代和Generator" class="headerlink" title="11.2 异步迭代和Generator"></a>11.2 异步迭代和Generator</h3><h4 id="1-异步迭代"><a href="#1-异步迭代" class="headerlink" title="1. 异步迭代"></a>1. 异步迭代</h4><p>当我们从网络中进行分片下载数据时，异步迭代来进行实现可能会更加方便。</p>
<p>要使对象异步迭代：</p>
<ol>
<li><p>使用 <code>Symbol.asyncIterator</code> 取代 <code>Symbol.iterator</code>。</p>
</li>
<li><p>next() 方法应该返回一个 promise（带有下一个值，并且状态为fulfilled）</p>
<ul>
<li> 关键字 <code>async</code> 可以实现这一点，我们可以简单地使用 <code>async next()</code>。</li>
</ul>
</li>
<li><p>我们应该使用 <code>for await (let item of iterable)</code> 循环来迭代这样的对象。</p>
<ul>
<li>注意关键字 <code>await</code>。</li>
</ul>
</li>
</ol>
<p>事实上，我们可以在对象中即可以异步迭代也可以同步迭代，只是这很奇怪罢了。</p>
<blockquote>
<p>异步迭代无法使用解构符。</p>
</blockquote>
<h4 id="2-异步generator"><a href="#2-异步generator" class="headerlink" title="2. 异步generator"></a>2. 异步generator</h4><p>和异步迭代类似，只需要在函数前面加一个async，使用时使用异步迭代的使用方式。</p>
<h2 id="12-模块-Module"><a href="#12-模块-Module" class="headerlink" title="12. 模块(Module)"></a>12. 模块(Module)</h2><h3 id="12-1-模块简介"><a href="#12-1-模块简介" class="headerlink" title="12.1. 模块简介"></a>12.1. 模块简介</h3><p>一个模块（module）就是一个文件。一个脚本就是一个模块。</p>
<ul>
<li><code>export</code> 关键字标记了可以从当前模块外部访问的变量和函数。</li>
<li><code>import</code> 关键字允许从其他模块导入功能。</li>
</ul>
<p>如果在HTML的Script标签中使用模块则需要告诉浏览器：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript">  <span class="hljs-keyword">import</span> &#123;sayHi&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./say.js&#x27;</span>;</span>
<span class="language-javascript"></span>
<span class="language-javascript">  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">innerHTML</span> = <span class="hljs-title function_">sayHi</span>(<span class="hljs-string">&#x27;John&#x27;</span>);</span>
<span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>

<blockquote>
<p>模块只通过 HTTP(s) 工作，在本地文件则不行。本地文件若想使用可以用Serve开启服务器。</p>
</blockquote>
<blockquote>
<p>模块始终使用<code>“user strict”</code></p>
</blockquote>
<blockquote>
<p>模块的作用域只有在自己的文件中才会有效</p>
</blockquote>
<blockquote>
<p>模块代码仅在第一次导入时被解析，被暴露的对象，在所有的导入中都只是一个，任意一个修改都会触发其它的修改</p>
</blockquote>
<blockquote>
<p>模块的顶级<code>this</code>是<code>undefined</code></p>
</blockquote>
<blockquote>
<p>模块加载总是<code>延迟的</code></p>
</blockquote>
<blockquote>
<p>具有 <code>type = &quot;module&quot; </code>属性相同的外部脚本&lt;script&gt;只会被执行一次</p>
</blockquote>
<blockquote>
<p><code>import</code>引入时必须包含绝对路径或者相对路径，没有路径的模块被称为<code>裸模块</code>，这是不被允许的</p>
</blockquote>
<h4 id="1-import-meta"><a href="#1-import-meta" class="headerlink" title="1. import.meta"></a>1. import.meta</h4><p><code>import.meta</code> 对象包含关于当前模块的信息。</p>
<p>它的内容取决于其所在的环境。在浏览器环境中，它包含当前脚本的 URL，或者如果它是在 HTML 中的话，则包含当前页面的 URL。</p>
<h4 id="2-兼容性"><a href="#2-兼容性" class="headerlink" title="2. 兼容性"></a>2. 兼容性</h4><p>早期的浏览器并不支持moudle，我们可以准备一个<code>nomodule</code>来用作不支持的情况。</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript">  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Runs in modern browsers&quot;</span>);</span>
<span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">nomodule</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript">  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Modern browsers know both type=module and nomodule, so skip this&quot;</span>)</span>
<span class="language-javascript">  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Old browsers ignore script with unknown type=module, but execute this.&quot;</span>);</span>
<span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>

<h4 id="3-构建工具"><a href="#3-构建工具" class="headerlink" title="3. 构建工具"></a>3. 构建工具</h4><p>它会帮助我们分析它的依赖，优化导入，处理过程中，删除无法访问的代码、未使用的导入等等，并且转换后它并不包含import或者export，这意味着它可以运行在不支持moudle的浏览器中。</p>
<h3 id="12-2-导入和导出"><a href="#12-2-导入和导出" class="headerlink" title="12.2. 导入和导出"></a>12.2. 导入和导出</h3><h4 id="1-声明前导出"><a href="#1-声明前导出" class="headerlink" title="1. 声明前导出"></a>1. 声明前导出</h4><p>我们可以通过在声明之前放置 <code>export</code> 来标记任意声明为导出，无论声明的是变量，函数还是类都可以。</p>
<blockquote>
<p>注意，导出的class和function末尾是没有分号的，这是因为export不会将其变成函数表达式，尽管被导出了，他仍然是一个函数声明。</p>
</blockquote>
<h4 id="2-分开导出"><a href="#2-分开导出" class="headerlink" title="2. 分开导出"></a>2. 分开导出</h4><pre><code class="hljs js"><span class="hljs-comment">// 📁 say.js</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params">user</span>) &#123;
  <span class="hljs-title function_">alert</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;user&#125;</span>!`</span>);
&#125;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">sayBye</span>(<span class="hljs-params">user</span>) &#123;
  <span class="hljs-title function_">alert</span>(<span class="hljs-string">`Bye, <span class="hljs-subst">$&#123;user&#125;</span>!`</span>);
&#125;

<span class="hljs-keyword">export</span> &#123;sayHi, sayBye&#125;; <span class="hljs-comment">// 导出变量列表</span></code></pre>

<h5 id="3-import"><a href="#3-import" class="headerlink" title="3. import"></a>3. import</h5><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;sayHi, sayBye&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./say.js&#x27;</span>;</code></pre>

<p>我们可以使用 <code>import * as &lt;obj&gt;</code> 将所有内容导入为一个对象</p>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> say <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./say.js&#x27;</span>;

say.<span class="hljs-title function_">sayHi</span>(<span class="hljs-string">&#x27;John&#x27;</span>);
say.<span class="hljs-title function_">sayBye</span>(<span class="hljs-string">&#x27;John&#x27;</span>);</code></pre>

<p><strong>不建议全部导出</strong>，这是因为在现代的构建工具中，它会根据导出进行优化，将那些未被导出的内容进行删除从而减少代码体量。</p>
<h4 id="4-import-as"><a href="#4-import-as" class="headerlink" title="4. import as"></a>4. import as</h4><p>为导入的内容取别名</p>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;sayHi <span class="hljs-keyword">as</span> hi, sayBye <span class="hljs-keyword">as</span> bye&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./say.js&#x27;</span>;

<span class="hljs-title function_">hi</span>(<span class="hljs-string">&#x27;John&#x27;</span>); <span class="hljs-comment">// Hello, John!</span>
<span class="hljs-title function_">bye</span>(<span class="hljs-string">&#x27;John&#x27;</span>); <span class="hljs-comment">// Bye, John!</span></code></pre>

<h4 id="5-export-as"><a href="#5-export-as" class="headerlink" title="5. export as"></a>5. export as</h4><p>为导出的内容取别名</p>
<pre><code class="hljs js"><span class="hljs-keyword">export</span> &#123;sayHi <span class="hljs-keyword">as</span> hi, sayBye <span class="hljs-keyword">as</span> bye&#125;;</code></pre>

<h4 id="6-export-default"><a href="#6-export-default" class="headerlink" title="6. export default"></a>6. export default</h4><p>每个js文件中只会有一个默认导出，默认导出在使用时（导入时）不需要使用花括号</p>
<table>
<thead>
<tr>
<th align="left">命名的导出</th>
<th align="left">默认的导出</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>export class User &#123;...&#125;</code></td>
<td align="left"><code>export default class User &#123;...&#125;</code></td>
</tr>
<tr>
<td align="left"><code>import &#123;User&#125; from ...</code></td>
<td align="left"><code>import User from ...</code></td>
</tr>
</tbody></table>
<blockquote>
<p>被默认导出的内容可以不需要命名</p>
</blockquote>
<p>另一种默认导出方式：</p>
<pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params">user</span>) &#123;
  <span class="hljs-title function_">alert</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;user&#125;</span>!`</span>);
&#125;

<span class="hljs-comment">// 就像我们在函数之前添加了 &quot;export default&quot; 一样</span>
<span class="hljs-keyword">export</span> &#123;sayHi <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span>&#125;;

<span class="hljs-comment">// 为默认导出命名</span>
<span class="hljs-keyword">import</span> &#123;<span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">User</span>, sayHi&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user.js&#x27;</span>;

<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&#x27;John&#x27;</span>);</code></pre>

<p>如果我们将所有东西 <code>*</code> 作为一个对象导入，那么 <code>default</code> 属性正是默认的导出：</p>
<pre><code class="hljs js"><span class="hljs-comment">// 📁 main.js</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> user <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user.js&#x27;</span>;

<span class="hljs-keyword">let</span> <span class="hljs-title class_">User</span> = user.<span class="hljs-property">default</span>; <span class="hljs-comment">// 默认的导出</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&#x27;John&#x27;</span>);</code></pre>

<blockquote>
<p>使用默认导出时，在团队工作中每个人为导入的命名可能都不一样，所以我们定下规则，导入的变量应该和文件名对应</p>
</blockquote>
<h4 id="7-重新导出"><a href="#7-重新导出" class="headerlink" title="7. 重新导出"></a>7. 重新导出</h4><p>“重新导出（Re-export）”语法 <code>export ... from ...</code> 允许导入内容，并立即将其导出（可能是用的是其他的名字）</p>
<p>什么时候使用它嘞？当我们编写<code>package</code>可能内部包含了许多的moudle，这些module可能会引用，这就需要进行导入导出，但是这些module我们又不希望被其它使用这个package的用户所导入，我们希望用户只能够导入我们规定为用户导出的内容，这就需要重新导出。</p>
<p>我们可以单独创建一个文件用来单独的重新导出我们规定的文件。</p>
<h4 id="8-重新导出默认导出"><a href="#8-重新导出默认导出" class="headerlink" title="8. 重新导出默认导出"></a>8. 重新导出默认导出</h4><p>普通的重新导出语法在进行重新导出时是无效的会有语法错误，进行全部重新导出时把并不会导出默认导出。</p>
<p>我们必须明确写出 <code>export &#123;default as User&#125; from &#39;./user.js&#39;;</code></p>
<h3 id="12-3-动态导入"><a href="#12-3-动态导入" class="headerlink" title="12.3. 动态导入"></a>12.3. 动态导入</h3><h4 id="import-表达式"><a href="#import-表达式" class="headerlink" title="import()表达式"></a>import()表达式</h4><p><code>import(module)</code> 表达式加载模块并返回一个 promise，该 promise resolve 为一个包含其所有导出的模块对象。我们可以在代码中的任意位置调用这个表达式。</p>
<blockquote>
<p>注意import并不是一个函数，尽管看起来像，但是我们不能像变量一样对其进行赋值，只是它的语法结构恰好和函数类似</p>
</blockquote>
<h2 id="13-杂项"><a href="#13-杂项" class="headerlink" title="13. 杂项"></a>13. 杂项</h2><h3 id="13-1-Proxy和Reflect"><a href="#13-1-Proxy和Reflect" class="headerlink" title="13.1 Proxy和Reflect"></a>13.1 Proxy和Reflect</h3><h4 id="1-Proxy"><a href="#1-Proxy" class="headerlink" title="1. Proxy"></a>1. Proxy</h4><pre><code class="hljs js"><span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler)</code></pre>

<ul>
<li><code>target</code> —— 是要包装的对象，可以是任何东西，包括函数。</li>
<li><code>handler</code> —— 代理配置：带有“捕捉器”（“traps”，即拦截操作的方法）的对象。比如 <code>get</code> 捕捉器用于读取 <code>target</code> 的属性，<code>set</code> 捕捉器用于写入 <code>target</code> 的属性，等等。</li>
</ul>
<p><code>Proxy</code> 是一种特殊的“奇异对象（exotic object）”。它没有自己的属性。如果 <code>handler</code> 为空，则透明地将操作转发给 <code>target</code>。</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> target = &#123;&#125;;
<span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, &#123;&#125;); <span class="hljs-comment">// 空的 handler 对象</span>

proxy.<span class="hljs-property">test</span> = <span class="hljs-number">5</span>; <span class="hljs-comment">// 写入 proxy 对象 (1)</span>
<span class="hljs-title function_">alert</span>(target.<span class="hljs-property">test</span>); <span class="hljs-comment">// 5，test 属性出现在了 target 中！</span>

<span class="hljs-title function_">alert</span>(proxy.<span class="hljs-property">test</span>); <span class="hljs-comment">// 5，我们也可以从 proxy 对象读取它 (2)</span></code></pre>

<p>对于对象的大多数操作，JavaScript 规范中有一个所谓的“内部方法”，它描述了最底层的工作方式。Proxy 捕捉器会拦截这些方法的调用。</p>
<table>
<thead>
<tr>
<th align="left">内部方法</th>
<th align="left">Handler 方法</th>
<th align="left">何时触发</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>[[Get]]</code></td>
<td align="left"><code>get</code></td>
<td align="left">读取属性</td>
</tr>
<tr>
<td align="left"><code>[[Set]]</code></td>
<td align="left"><code>set</code></td>
<td align="left">写入属性</td>
</tr>
<tr>
<td align="left"><code>[[HasProperty]]</code></td>
<td align="left"><code>has</code></td>
<td align="left"><code>in</code> 操作符</td>
</tr>
<tr>
<td align="left"><code>[[Delete]]</code></td>
<td align="left"><code>deleteProperty</code></td>
<td align="left"><code>delete</code> 操作符</td>
</tr>
<tr>
<td align="left"><code>[[Call]]</code></td>
<td align="left"><code>apply</code></td>
<td align="left">函数调用</td>
</tr>
<tr>
<td align="left"><code>[[Construct]]</code></td>
<td align="left"><code>construct</code></td>
<td align="left"><code>new</code> 操作符</td>
</tr>
<tr>
<td align="left"><code>[[GetPrototypeOf]]</code></td>
<td align="left"><code>getPrototypeOf</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf">Object.getPrototypeOf</a></td>
</tr>
<tr>
<td align="left"><code>[[SetPrototypeOf]]</code></td>
<td align="left"><code>setPrototypeOf</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf">Object.setPrototypeOf</a></td>
</tr>
<tr>
<td align="left"><code>[[IsExtensible]]</code></td>
<td align="left"><code>isExtensible</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible">Object.isExtensible</a></td>
</tr>
<tr>
<td align="left"><code>[[PreventExtensions]]</code></td>
<td align="left"><code>preventExtensions</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions">Object.preventExtensions</a></td>
</tr>
<tr>
<td align="left"><code>[[DefineOwnProperty]]</code></td>
<td align="left"><code>defineProperty</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty</a>, <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties">Object.defineProperties</a></td>
</tr>
<tr>
<td align="left"><code>[[GetOwnProperty]]</code></td>
<td align="left"><code>getOwnPropertyDescriptor</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor">Object.getOwnPropertyDescriptor</a>, <code>for..in</code>, <code>Object.keys/values/entries</code></td>
</tr>
<tr>
<td align="left"><code>[[OwnPropertyKeys]]</code></td>
<td align="left"><code>ownKeys</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames">Object.getOwnPropertyNames</a>, <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols">Object.getOwnPropertySymbols</a>, <code>for..in</code>, <code>Object/keys/values/entries</code></td>
</tr>
</tbody></table>
<blockquote>
<p>不变量：JavaScript 强制执行某些不变量 — 内部方法和捕捉器必须满足的条件。</p>
</blockquote>
<h4 id="2-Get使用"><a href="#2-Get使用" class="headerlink" title="2. Get使用"></a>2. Get使用</h4><p><code>get(target, property, receiver)</code></p>
<ul>
<li><code>target</code> —— 是目标对象，该对象被作为第一个参数传递给 <code>new Proxy</code>，</li>
<li><code>property</code> —— 目标属性名，</li>
<li><code>receiver</code> —— 如果目标属性是一个 getter 访问器属性，则 <code>receiver</code> 就是本次读取属性所在的 <code>this</code> 对象。通常，这就是 <code>proxy</code> 对象本身（或者，如果我们从 proxy 继承，则是从该 proxy 继承的对象）。现在我们不需要此参数，因此稍后我们将对其进行详细介绍。</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];

numbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(numbers, &#123;
    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, prop</span>) &#123;
        <span class="hljs-keyword">if</span> (prop <span class="hljs-keyword">in</span> target) &#123;
            <span class="hljs-keyword">return</span> target[prop];
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 默认值</span>
        &#125;
    &#125;
&#125;);

<span class="hljs-title function_">alert</span>( numbers[<span class="hljs-number">1</span>] ); <span class="hljs-comment">// 1</span>
<span class="hljs-title function_">alert</span>( numbers[<span class="hljs-number">123</span>] ); <span class="hljs-comment">// 0（没有这个数组项）</span></code></pre>

<blockquote>
<p>注意当对象被代理后，代理应该在所有地方都完全替代目标对象。目标对象被代理后，任何人都不应该再引用目标对象。否则很容易搞砸。</p>
</blockquote>
<h4 id="3-Set"><a href="#3-Set" class="headerlink" title="3. Set"></a>3. Set</h4><p><code>set(target, property, value, receiver)</code>：</p>
<ul>
<li><code>target</code> —— 是目标对象，该对象被作为第一个参数传递给 <code>new Proxy</code>，</li>
<li><code>property</code> —— 目标属性名称，</li>
<li><code>value</code> —— 目标属性的值，</li>
<li><code>receiver</code> —— 与 <code>get</code> 捕捉器类似，仅与 setter 访问器属性相关。</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> numbers = [];

numbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(numbers, &#123; <span class="hljs-comment">// (*)</span>
    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, prop, val</span>) &#123; <span class="hljs-comment">// 拦截写入属性操作</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> val == <span class="hljs-string">&#x27;number&#x27;</span>) &#123;
            target[prop] = val;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        &#125;
    &#125;
&#125;);

numbers.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 添加成功</span>
numbers.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;test&quot;</span>); <span class="hljs-comment">// TypeError（proxy 的 &#x27;set&#x27; 返回 false）</span></code></pre>

<blockquote>
<p>请注意：数组的内建方法依然有效！值被使用 <code>push</code> 方法添加到数组。当值被添加到数组后，数组的 <code>length</code> 属性会自动增加。我们的代理对象 proxy 不会破坏任何东西。</p>
</blockquote>
<p>// TODO</p>
<h3 id="13-2-Eval：执行代码字符串"><a href="#13-2-Eval：执行代码字符串" class="headerlink" title="13.2 Eval：执行代码字符串"></a>13.2 Eval：执行代码字符串</h3><p>内建函数 <code>eval</code> 允许执行一个代码字符串。</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> code = <span class="hljs-string">&#x27;alert(&quot;Hello&quot;)&#x27;</span>;
<span class="hljs-built_in">eval</span>(code); <span class="hljs-comment">// Hello</span></code></pre>

<p><code>eval</code> 内的代码在当前词法环境（lexical environment）中执行，因此它能访问外部变量，同时也可以修改。</p>
<blockquote>
<p>在严格模式下，eval有自己的词法环境，不能在外界获取它的函数和变量。</p>
</blockquote>
<p>请注意，<code>eval</code> 访问外部变量的能力会产生副作用。在代码压缩工具中，由于eval中的变量无法访问，这回造成压缩效率的降低，因此在 <code>eval</code> 中使用外部局部变量也被认为是一个坏的编程习惯，因为这会使代码维护变得更加困难。</p>
<blockquote>
<p>如果 eval 中的代码没有使用外部变量，请以 window.eval(…) 的形式调用 eval，eval中的环境就变成了window</p>
</blockquote>
<h3 id="13-3-柯里化"><a href="#13-3-柯里化" class="headerlink" title="13.3 柯里化"></a>13.3 柯里化</h3><p>柯里化是一种函数的转换，它是指将一个函数从可调用的 <code>f(a, b, c)</code> 转换为可调用的 <code>f(a)(b)(c)</code>。</p>
<p>柯里化更高级的实现，例如 lodash 库的<code> _.curry</code>，会返回一个包装器，该包装器允许函数被正常调用或者以偏函数（partial）的方式调用</p>
<h4 id="高级柯里化"><a href="#高级柯里化" class="headerlink" title="高级柯里化"></a>高级柯里化</h4><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">func</span>) &#123;

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">curried</span>(<span class="hljs-params">...args</span>) &#123;
        <span class="hljs-comment">// 和函数本身的应该的参数列表进行比较</span>
        <span class="hljs-keyword">if</span> (args.<span class="hljs-property">length</span> &gt;= func.<span class="hljs-property">length</span>) &#123; 
            <span class="hljs-keyword">return</span> func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args2</span>) &#123;
                <span class="hljs-comment">// 如果小于的话就保存到当前的词法环境中，并与当前词法环境已经含有的参数进行拼接</span>
                <span class="hljs-keyword">return</span> curried.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args.<span class="hljs-title function_">concat</span>(args2));
            &#125;
        &#125;
    &#125;;

&#125;</code></pre>

<blockquote>
<p>柯里化要求函数的参数必须是固定的，换句话说含有 rest 参数的函数无法进行柯里化。</p>
</blockquote>
<h3 id="13-4-Reference-Type"><a href="#13-4-Reference-Type" class="headerlink" title="13.4 Reference Type"></a>13.4 Reference Type</h3><p>实际上，当我执行对象中的一个函数时 <code>user.sayHi()</code> “<code>.</code>”后sayHi返回的并不是一个sayHi函数，而是一个 Reference Type 值。</p>
<p>Reference Type 的值是一个三个值的组合 <code>(base, name, strict)</code>，其中：</p>
<ul>
<li><code>base</code> 是对象。</li>
<li><code>name</code> 是属性名。</li>
<li><code>strict</code> 在 <code>use strict</code> 模式下为 true。</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// Reference Type 的值</span>
(user, <span class="hljs-string">&quot;sayHi&quot;</span>, <span class="hljs-literal">true</span>)</code></pre>

<p>任何例如赋值 <code>hi = user.sayHi</code> 等其他的操作，都会将 Reference Type 作为一个整体丢弃掉，而会取 <code>user.sayHi</code>（一个函数）的值并继续传递。所以任何后续操作都“丢失”了 <code>this</code>。(使用 <code>[] </code>取作用类似)</p>
<h1 id="2-浏览器：文档、事件、接口"><a href="#2-浏览器：文档、事件、接口" class="headerlink" title="2. 浏览器：文档、事件、接口"></a>2. 浏览器：文档、事件、接口</h1><p><img src="https://i.loli.net/2021/07/26/xwJYKbFfMpGcLXy.png" alt="image-20210726103325828"></p>
<h2 id="1-Document"><a href="#1-Document" class="headerlink" title="1. Document"></a>1. Document</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><h4 id="1-DOM"><a href="#1-DOM" class="headerlink" title="1. DOM"></a>1. DOM</h4><p>文档对象模型（Document Object Model），简称 DOM，将所有页面内容表示为可以修改的对象。</p>
<h4 id="2-CSSOM"><a href="#2-CSSOM" class="headerlink" title="2. CSSOM"></a>2. CSSOM</h4><p>一份针对 CSS 规则和样式表的、单独的规范 <a href="https://www.w3.org/TR/cssom-1/">CSS Object Model (CSSOM)</a>，这份规范解释了如何将 CSS 表示为对象，以及如何读写这些对象。</p>
<p>当我们修改文档的样式规则时，CSSOM 与 DOM 是一起使用的。但实际上，很少需要 CSSOM，因为我们很少需要从 JavaScript 中修改 CSS 规则（我们通常只是添加/移除一些 CSS 类，而不是直接修改其中的 CSS 规则），但这也是可行的。</p>
<h4 id="3-BOM"><a href="#3-BOM" class="headerlink" title="3. BOM"></a>3. BOM</h4><p>浏览器对象模型（Browser Object Model），简称 BOM，表示由浏览器（主机环境）提供的用于处理文档（document）之外的所有内容的其他对象。</p>
<h3 id="1-2-DOM树"><a href="#1-2-DOM树" class="headerlink" title="1.2 DOM树"></a>1.2 DOM树</h3><p>HTML 文档的主干是标签（tag）。</p>
<p>根据文档对象模型（DOM），每个 HTML 标签都是一个对象。嵌套的标签是闭合标签的“子标签（children）”。标签内的文本也是一个对象。</p>
<p>标签被称为 <strong>元素节点</strong>（或者仅仅是元素），并形成了树状结构：<code>&lt;html&gt;</code> 在根节点，<code>&lt;head&gt;</code> 和 <code>&lt;body&gt;</code> 是其子项，等。</p>
<p>元素内的文本形成 <strong>文本节点</strong>，被标记为 <code>＃text</code>。一个文本节点只包含一个字符串。它没有子项，并且总是树的叶子。</p>
<p>注释也会成为一个节点，被标记为 <code>#comment</code>。</p>
<blockquote>
<p><strong>HTML 中的所有内容，甚至注释，都会成为 DOM 的一部分。</strong></p>
</blockquote>
<p>标签中空格和换行符都是完全有效的字符，它们形成文本节点并成为 DOM 的一部分。</p>
<p>只有两个顶级排除项：</p>
<ol>
<li>由于历史原因，<code>&lt;head&gt;</code> 之前的空格和换行符均被忽略。</li>
<li>如果我们在 <code>&lt;/body&gt;</code> 之后放置一些东西，那么它会被自动移动到 <code>body</code> 内，并处于 <code>body</code> 中的最下方，因为 HTML 规范要求所有内容必须位于 <code>&lt;body&gt;</code> 内。所以 <code>&lt;/body&gt;</code> 之后不能有空格。</li>
</ol>
<p>一共有 <a href="https://dom.spec.whatwg.org/#node">12 种节点类型</a>。实际上，我们通常用到的是其中的 4 种：</p>
<ol>
<li><code>document</code> — DOM 的“入口点”。</li>
<li>元素节点 — HTML 标签，树构建块。</li>
<li>文本节点 — 包含文本。</li>
<li>注释 — 有时我们可以将一些信息放入其中，它不会显示，但 JS 可以从 DOM 中读取它。</li>
</ol>
<h4 id="自动修正"><a href="#自动修正" class="headerlink" title="自动修正"></a>自动修正</h4><p>如果浏览器遇到格式不正确的 HTML，它会在形成 DOM 时自动更正它。</p>
<p>例如 html 和 body 标签，即使它不存在于文档中，也会被自动创建。</p>
<p>未闭合的标签会进行自动闭合。</p>
<blockquote>
<p>表格永远有&lt;tbody&gt;</p>
</blockquote>
<h3 id="1-3-DOM遍历"><a href="#1-3-DOM遍历" class="headerlink" title="1.3 DOM遍历"></a>1.3 DOM遍历</h3><h4 id="1-顶层节点"><a href="#1-顶层节点" class="headerlink" title="1. 顶层节点"></a>1. 顶层节点</h4><p>&lt;html&gt;<code>=</code>document.documentElement</p>
<p>最顶层的 document 节点是 <code>document.documentElement</code>。这是对应 <code>&lt;html&gt;</code> 标签的 DOM 节点。</p>
<p>&lt;body&gt;<code>=</code>document.body`</p>
<p>另一个被广泛使用的 DOM 节点是 <code>&lt;body&gt;</code> 元素 — <code>document.body</code>。</p>
<p>&lt;head&gt;<code>=</code>document.head</p>
<p><code>&lt;head&gt;</code> 标签可以通过 <code>document.head</code> 访问。</p>
<blockquote>
<p>如果在body渲染前进行读body对象（代码在head中），那么返回的为空。</p>
</blockquote>
<h4 id="2-子节点"><a href="#2-子节点" class="headerlink" title="2. 子节点"></a>2. 子节点</h4><ul>
<li><strong>子节点（或者叫作子）</strong> — 对应的是直系的子元素。换句话说，它们被完全嵌套在给定的元素中。例如，<code>&lt;head&gt;</code> 和 <code>&lt;body&gt;</code> 就是 <code>&lt;html&gt;</code> 元素的子元素。</li>
<li><strong>子孙元素</strong> — 嵌套在给定元素中的所有元素，包括子元素，以及子元素的子元素等。</li>
</ul>
<p><code>firstChild</code> 和 <code>lastChild</code> 属性是访问第一个和最后一个子元素的快捷方式。</p>
<p>这里还有一个特别的函数 <code>elem.hasChildNodes()</code> 用于检查节点是否有子节点。</p>
<p>正如我们看到的那样，<code>childNodes</code> 看起来就像一个数组。但实际上它并不是一个数组，而是一个 <strong>集合</strong> — 一个类数组的可迭代对象。</p>
<p>反应在该性质上就是：</p>
<ul>
<li>可以使用 for of 进行迭代</li>
<li>无法使用数组相关的方法</li>
</ul>
<p><strong>DOM 集合是只读的</strong></p>
<p>无法通过更改集合来反向应该DOM</p>
<p><strong>DOM 集合是实时的</strong></p>
<p>如果在其他地方更改DOM，那么DOM集合也会实时更新</p>
<p><strong>不要使用 for..in 来遍历集合</strong></p>
<p><code>for..in</code> 循环遍历的是所有可枚举的（enumerable）属性。集合还有一些“额外的”很少被用到的属性，通常这些属性也是我们不期望得到的。</p>
<h4 id="3-兄弟节点和父节点"><a href="#3-兄弟节点和父节点" class="headerlink" title="3. 兄弟节点和父节点"></a>3. 兄弟节点和父节点</h4><p>下一个兄弟节点在 <code>nextSibling</code> 属性中，上一个是在 <code>previousSibling</code> 属性中。</p>
<p>可以通过 <code>parentNode</code> 来访问父节点。</p>
<h4 id="4-纯元素导航"><a href="#4-纯元素导航" class="headerlink" title="4. 纯元素导航"></a>4. 纯元素导航</h4><p>在上面的访问方式中，我们可以访问到元素的所有节点，但是有时候我们不需要访问它的文本节点或者注释节点。我们希望操纵的是代表标签的和形成页面结构的元素节点。</p>
<p>这些链接和我们在上面提到过的类似，只是在词中间加了 <code>Element</code>：</p>
<ul>
<li><code>children</code> — 仅那些作为元素节点的子代的节点。</li>
<li><code>firstElementChild</code>，<code>lastElementChild</code> — 第一个和最后一个子元素。</li>
<li><code>previousElementSibling</code>，<code>nextElementSibling</code> — 兄弟元素。</li>
<li><code>parentElement</code> — 父元素。</li>
</ul>
<p>parentElement 访问父元素，parentNode访问父节点，弹道父节点和父元素可以不是同一个元素吗？它在几乎所有的情况下都满足，除了一个例外：</p>
<pre><code class="hljs js"><span class="hljs-title function_">alert</span>( <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">parentNode</span> ); <span class="hljs-comment">// document</span>
<span class="hljs-title function_">alert</span>( <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">parentElement</span> ); <span class="hljs-comment">// null</span></code></pre>

<p>原因就是 document不是一个元素节点。</p>
<h4 id="5-其它特殊属性"><a href="#5-其它特殊属性" class="headerlink" title="5. 其它特殊属性"></a>5. 其它特殊属性</h4><p>方便起见，某些类型的 DOM 元素可能会提供特定于其类型的其他属性。</p>
<p>表格（Table）是一个很好的例子，它代表了一个特别重要的情况：</p>
<p>&lt;table&gt; 元素支持 (除了上面给出的，之外) 以下这些属性:</p>
<ul>
<li>table.rows — &lt;tr&gt; 元素的集合。</li>
<li>table.caption/tHead/tFoot — 引用元素 &lt;caption&gt;，&lt;thead&gt;，&lt;tfoot&gt;。</li>
<li>table.tBodies — &lt;tbody&gt; 元素的集合（根据标准还有很多元素，但是这里至少会有一个 — 即使没有被写在 HTML 源文件中，浏览器也会将其放入 DOM 中）。</li>
</ul>
<p><code>&lt;thead&gt;</code>，<code>&lt;tfoot&gt;</code>，<code>&lt;tbody&gt;</code> 元素提供了 <code>rows</code> 属性：</p>
<ul>
<li><code>tbody.rows</code> — 表格内部 <code>&lt;tr&gt;</code> 元素的集合。</li>
</ul>
<p><code>&lt;tr&gt;</code>：</p>
<ul>
<li><code>tr.cells</code> — 在给定 <code>&lt;tr&gt;</code> 中的 <code>&lt;td&gt;</code> 和 <code>&lt;th&gt;</code> 单元格的集合。</li>
<li><code>tr.sectionRowIndex</code> — 给定的 <code>&lt;tr&gt;</code> 在封闭的 <code>&lt;thead&gt;/&lt;tbody&gt;/&lt;tfoot&gt;</code> 中的位置（索引）。</li>
<li><code>tr.rowIndex</code> — 在整个表格中 <code>&lt;tr&gt;</code> 的编号（包括表格的所有行）。</li>
</ul>
<p><code>&lt;td&gt;</code> 和 <code>&lt;th&gt;</code>：</p>
<ul>
<li><code>td.cellIndex</code> — 在封闭的 <code>&lt;tr&gt;</code> 中单元格的编号。</li>
</ul>
<h3 id="1-4-元素节点搜索"><a href="#1-4-元素节点搜索" class="headerlink" title="1.4 元素节点搜索"></a>1.4 元素节点搜索</h3><h4 id="1-document-getElementById-或者只使用-id"><a href="#1-document-getElementById-或者只使用-id" class="headerlink" title="1. document.getElementById 或者只使用 id"></a>1. document.getElementById 或者只使用 id</h4><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;elem&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;elem-content&quot;</span>&gt;</span>Element<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript">    <span class="hljs-comment">// 第一种方式</span></span>
<span class="language-javascript">    <span class="hljs-comment">// elem 是对带有 id=&quot;elem&quot; 的 DOM 元素的引用</span></span>
<span class="language-javascript">    elem.<span class="hljs-property">style</span>.<span class="hljs-property">background</span> = <span class="hljs-string">&#x27;red&#x27;</span>;</span>
<span class="language-javascript"></span>
<span class="language-javascript">    <span class="hljs-comment">// id=&quot;elem-content&quot; 内有连字符，所以它不能成为一个变量</span></span>
<span class="language-javascript">    <span class="hljs-comment">// ...但是我们可以通过使用方括号 window[&#x27;elem-content&#x27;] 来访问它</span></span>
<span class="language-javascript"></span>
<span class="language-javascript">    <span class="hljs-comment">// 第二种方式</span></span>
<span class="language-javascript">    <span class="hljs-comment">// 获取该元素，这种方式优先级高，会覆盖第一种</span></span>
<span class="language-javascript">    <span class="hljs-keyword">let</span> elem = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;elem&#x27;</span>);</span>
<span class="language-javascript"></span>
<span class="language-javascript">    <span class="hljs-comment">// 将该元素背景改为红色</span></span>
<span class="language-javascript">    elem.<span class="hljs-property">style</span>.<span class="hljs-property">background</span> = <span class="hljs-string">&#x27;red&#x27;</span>;</span>
<span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>

<blockquote>
<p>第一种方式只是为了兼容性才使用它，除非特殊情况，那么不建议使用它，容易造成冲突。</p>
</blockquote>
<h4 id="2-querySelectorAll"><a href="#2-querySelectorAll" class="headerlink" title="2. querySelectorAll"></a>2. querySelectorAll</h4><p>到目前为止，最通用的方法是 <code>elem.querySelectorAll(css)</code>，它返回 <code>elem</code> 中与给定 CSS 选择器匹配的所有元素。</p>
<h4 id="3-querySelector"><a href="#3-querySelector" class="headerlink" title="3. querySelector"></a>3. querySelector</h4><p><code>elem.querySelector(css)</code> 调用会返回给定 CSS 选择器的<code>第一个</code>元素。</p>
<p>换句话说，结果与 <code>elem.querySelectorAll(css)[0]</code> 相同，但是后者会查找 <strong>所有</strong> 元素，并从中选取一个，而 <code>elem.querySelector</code> 只会查找一个。因此它在速度上更快，并且写起来更短。</p>
<h4 id="4-matches"><a href="#4-matches" class="headerlink" title="4. matches"></a>4. matches</h4><p><a href="http://dom.spec.whatwg.org/#dom-element-matches">elem.matches(css)</a> 不会查找任何内容，它只会检查 <code>elem</code> 是否与给定的 CSS 选择器匹配。它返回 <code>true</code> 或 <code>false</code>。</p>
<h4 id="5-closest"><a href="#5-closest" class="headerlink" title="5. closest"></a>5. closest</h4><p><code>elem.closest(css)</code> 方法会查找与 CSS 选择器匹配的最近的祖先。<code>elem</code> 自己也会被搜索。</p>
<h4 id="6-getElementsBy"><a href="#6-getElementsBy" class="headerlink" title="6. getElementsBy*"></a>6. getElementsBy*</h4><ul>
<li><code>elem.getElementsByTagName(tag)</code> 查找具有给定标签的元素，并返回它们的集合。<code>tag</code> 参数也可以是对于“任何标签”的星号 <code>&quot;*&quot;</code>。</li>
<li><code>elem.getElementsByClassName(className)</code> 返回具有给定CSS类的元素。</li>
<li><code>document.getElementsByName(name)</code> 返回在文档范围内具有给定 <code>name</code> 特性的元素。很少使用。</li>
</ul>
<p>这些方法已经成为了历史，因为 querySelector 过于强大，且写起来更短。</p>
<blockquote>
<p>注意上面的方法返回的是一个集合而不是一个元素。这在使用时需要小心。</p>
</blockquote>
<p>所有的 <code>&quot;getElementsBy*&quot;</code> 方法都会返回一个 <strong>实时的（live）</strong> 集合。</p>
<p>相反，<code>querySelectorAll</code> 返回的是一个 <strong>静态的</strong> 集合。</p>
<h3 id="1-5-节点属性"><a href="#1-5-节点属性" class="headerlink" title="1.5 节点属性"></a>1.5 节点属性</h3><h4 id="1-DOM节点类"><a href="#1-DOM节点类" class="headerlink" title="1. DOM节点类"></a>1. DOM节点类</h4><p>每个DOM节点都有一个与之对应的内建类，类中的属性和方法既有共同的，也有不同的。</p>
<p>层次结构（hierarchy）的根节点是 <a href="https://dom.spec.whatwg.org/#eventtarget">EventTarget</a>，<a href="http://dom.spec.whatwg.org/#interface-node">Node</a> 继承自它，其他 DOM 节点继承自 Node。</p>
<p><img src="https://i.loli.net/2021/07/26/4koBRwGJfQNx9UE.png" alt="image-20210726115658582"></p>
<p><strong>nodeType 属性</strong></p>
<p><code>nodeType</code> 属性提供了另一种“过时的”用来获取 DOM 节点类型的方法。</p>
<p>它有一个数值型值（numeric value）：</p>
<ul>
<li>对于元素节点 <code>elem.nodeType == 1</code>，</li>
<li>对于文本节点 <code>elem.nodeType == 3</code>，</li>
<li>对于 document 对象 <code>elem.nodeType == 9</code>，</li>
<li>在 <a href="https://dom.spec.whatwg.org/#node">规范</a> 中还有一些其他值。</li>
</ul>
<h4 id="2-nodeName和tagName"><a href="#2-nodeName和tagName" class="headerlink" title="2. nodeName和tagName"></a>2. nodeName和tagName</h4><p>当然，差异就体现在它们的名字上，但确实有些微妙。</p>
<ul>
<li>tagName 属性仅适用于 Element 节点。</li>
<li>nodeName 是为任意 Node 定义的：<ul>
<li>对于元素，它的意义与 tagName 相同。</li>
<li>对于其他节点类型（text，comment 等），它拥有一个对应节点类型的字符串。</li>
</ul>
</li>
</ul>
<p><strong>标签名称始终是大写的，除非在XML模式下</strong></p>
<p>浏览器有两种处理文档（document）的模式：HTML 和 XML。通常，HTML 模式用于网页。只有在浏览器接收到带有 header <code>Content-Type: application/xml+xhtml</code> 的 XML-document 时，XML 模式才会被启用。</p>
<p>在 HTML 模式下，<code>tagName/nodeName</code> 始终是大写的：它是 <code>BODY</code>，而不是 <code>&lt;body&gt;</code> 或 <code>&lt;BoDy&gt;</code>。</p>
<p>在 XML 模式中，大小写保持为“原样”。如今，XML 模式很少被使用。</p>
<h4 id="3-innerHTML"><a href="#3-innerHTML" class="headerlink" title="3. innerHTML"></a>3. innerHTML</h4><p><a href="https://w3c.github.io/DOM-Parsing/#the-innerhtml-mixin">innerHTML</a> 属性允许将元素中的 HTML 获取为字符串形式。</p>
<p>我们也可以修改它。因此，它是更改页面最有效的方法之一。</p>
<blockquote>
<p>如果 <code>innerHTML</code> 将一个 <code>&lt;script&gt;</code> 标签插入到 document 中 — 它会成为 HTML 的一部分，但是不会执行。</p>
</blockquote>
<p><strong>小心：“innerHTML+=” 会进行完全重写</strong></p>
<p>即原来的内容会重新加载。</p>
<h4 id="4-outerHTML"><a href="#4-outerHTML" class="headerlink" title="4. outerHTML"></a>4. outerHTML</h4><p>功能和 innerHTML类似，但是它改变了标签本身。</p>
<h4 id="5-nodeValue-data：文本节点内容"><a href="#5-nodeValue-data：文本节点内容" class="headerlink" title="5. nodeValue/data：文本节点内容"></a>5. nodeValue/data：文本节点内容</h4><p><code>innerHTML</code> 属性仅对元素节点有效。</p>
<p>其他节点类型，例如文本节点，具有它们的对应项：<code>nodeValue</code> 和 <code>data</code> 属性。这两者在实际使用中几乎相同，只有细微规范上的差异。因此，我们将使用 <code>data</code>，因为它更短。</p>
<h4 id="6-textContent：纯文本"><a href="#6-textContent：纯文本" class="headerlink" title="6. textContent：纯文本"></a>6. textContent：纯文本</h4><p><code>textContent</code> 提供了对元素内的 <strong>文本</strong> 的访问权限：仅文本，去掉所有 <code>&lt;tags&gt;</code>。可以利用此修改标签内的文本内容</p>
<h4 id="7-“hidden”属性"><a href="#7-“hidden”属性" class="headerlink" title="7. “hidden”属性"></a>7. “hidden”属性</h4><p>从技术上来说，<code>hidden</code> 与 <code>style=&quot;display:none&quot;</code> 做的是相同的事。但 <code>hidden</code> 写法更简洁。</p>
<h3 id="1-6-特性和属性"><a href="#1-6-特性和属性" class="headerlink" title="1.6 特性和属性"></a>1.6 特性和属性</h3><p>DOM 属性和方法的行为就像常规的 Javascript 对象一样：</p>
<ul>
<li>它们可以有很多值。</li>
<li>它们是大小写敏感的（要写成 <code>elem.nodeType</code>，而不是 <code>elem.NoDeTyPe</code>）。</li>
</ul>
<h4 id="1-特性"><a href="#1-特性" class="headerlink" title="1. 特性"></a>1. 特性</h4><p>在 HTML 中，标签可能拥有特性（attributes）。当浏览器解析 HTML 文本，并根据标签创建 DOM 对象时，浏览器会辨别 <strong>标准的</strong> 特性并以此创建 DOM 属性。</p>
<blockquote>
<p>请注意，一个元素的标准的特性对于另一个元素可能是未知的。</p>
</blockquote>
<p>当然。所有特性都可以通过使用以下方法进行访问：</p>
<ul>
<li><code>elem.hasAttribute(name)</code> — 检查特性是否存在。</li>
<li><code>elem.getAttribute(name)</code> — 获取这个特性值。</li>
<li><code>elem.attributes()</code> — 读取所有特性。属于内建 <a href="https://dom.spec.whatwg.org/#attr">Attr</a> 类的对象的集合，具有 <code>name</code> 和 <code>value</code> 属性。</li>
<li><code>elem.setAttribute(name, value)</code> — 设置这个特性值。</li>
<li><code>elem.removeAttribute(name)</code> — 移除这个特性。</li>
</ul>
<p>HTML 特性有以下几个特征：</p>
<ul>
<li>它们的名字是大小写不敏感的（<code>id</code> 与 <code>ID</code> 相同）。</li>
<li>它们的值总是字符串类型的。</li>
</ul>
<h4 id="2-属性—特性同步"><a href="#2-属性—特性同步" class="headerlink" title="2. 属性—特性同步"></a>2. 属性—特性同步</h4><p>一个标准的特性被改变，对应的属性也会自动更新，（除了几个特例）反之亦然。</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;input&#x27;</span>);

<span class="hljs-comment">// 特性 =&gt; 属性</span>
input.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;value&#x27;</span>, <span class="hljs-string">&#x27;text&#x27;</span>);
<span class="hljs-title function_">alert</span>(input.<span class="hljs-property">value</span>); <span class="hljs-comment">// text</span>

<span class="hljs-comment">// 这个操作无效，属性 =&gt; 特性</span>
input.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;newValue&#x27;</span>;
<span class="hljs-title function_">alert</span>(input.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;value&#x27;</span>)); <span class="hljs-comment">// text（没有被更新！）</span></code></pre>

<p>但是我们可以在屏幕的显示上看到值已经被修改。</p>
<p>这个“功能”在实际中会派上用场，因为用户行为可能会导致 <code>value</code> 的更改，然后在这些操作之后，如果我们想从 HTML 中恢复“原始”值，那么该值就在特性中。</p>
<blockquote>
<p>属性和特性的区别，属性是DOM对应对象上的属性，特性是HTML包含的特性。</p>
</blockquote>
<h4 id="3-特性冲突"><a href="#3-特性冲突" class="headerlink" title="3. 特性冲突"></a>3. 特性冲突</h4><p>如果开发者自定义的特性在未来被引入到标准的特性中，那么就会产生冲突。所有以 “data-” 开头的特性均被保留供程序员使用。它们可在 dataset 属性中使用。</p>
<p>例如，如果一个 <code>elem</code> 有一个名为 <code>&quot;data-about&quot;</code> 的特性，那么可以通过 <code>elem.dataset.about</code> 取到它。</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">data-about</span>=<span class="hljs-string">&quot;Elephants&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">dataset</span>.<span class="hljs-property">about</span>); <span class="hljs-comment">// Elephants</span></span>
<span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>

<p>像 <code>data-order-state</code> 这样的多词特性可以以驼峰式进行调用：<code>dataset.orderState</code>。</p>
<h3 id="1-7-DOM修改"><a href="#1-7-DOM修改" class="headerlink" title="1.7 DOM修改"></a>1.7 DOM修改</h3><h4 id="1-创建一个元素"><a href="#1-创建一个元素" class="headerlink" title="1. 创建一个元素"></a>1. 创建一个元素</h4><p>**document.createElement(tag)**：创建一个元素节点</p>
<p>**document.createTextNode(text)**：创建一个文本节点</p>
<p>上面只是在JS中创建一个DOM对象，但是在HTML中我们还无法看到。</p>
<p>在node节点位置上插入创建的节点：</p>
<ul>
<li><code>node.append(...nodes or strings)</code> —— 在 <code>node</code> <strong>末尾</strong> 插入节点或字符串，</li>
<li><code>node.prepend(...nodes or strings)</code> —— 在 <code>node</code> <strong>开头</strong> 插入节点或字符串，</li>
<li><code>node.before(...nodes or strings)</code> —— 在 <code>node</code> <strong>前面</strong> 插入节点或字符串，</li>
<li><code>node.after(...nodes or strings)</code> —— 在 <code>node</code> <strong>后面</strong> 插入节点或字符串，</li>
<li><code>node.replaceWith(...nodes or strings)</code> —— 将 <code>node</code> 替换为给定的节点或字符串。</li>
</ul>
<p><img src="https://i.loli.net/2021/07/26/TdbQV24jFcWI7Gq.png" alt="image-20210726151103250"></p>
<p>当我们插入的是字符串时，它会以”文本形式“插入，而不是“HTML代码”插入，如果写的时HTML代码也会被<code>转义</code>。</p>
<h4 id="2-insertAdjacentHTML-Text-Element"><a href="#2-insertAdjacentHTML-Text-Element" class="headerlink" title="2. insertAdjacentHTML/Text/Element"></a>2. insertAdjacentHTML/Text/Element</h4><p>在上面中，如果我们就想像innerHTML一样使用，为此，我们可以使用另一个非常通用的方法：<code>elem.insertAdjacentHTML(where, html)</code>。</p>
<p>该方法的第一个参数是代码字（code word），指定相对于 <code>elem</code> 的插入位置。必须为以下之一：</p>
<ul>
<li><code>&quot;beforebegin&quot;</code> — 将 <code>html</code> 插入到 <code>elem</code> 前插入，</li>
<li><code>&quot;afterbegin&quot;</code> — 将 <code>html</code> 插入到 <code>elem</code> 开头，</li>
<li><code>&quot;beforeend&quot;</code> — 将 <code>html</code> 插入到 <code>elem</code> 末尾，</li>
<li><code>&quot;afterend&quot;</code> — 将 <code>html</code> 插入到 <code>elem</code> 后。</li>
</ul>
<p><img src="https://i.loli.net/2021/07/26/hZBs3EjkbrmSc4Y.png" alt="image-20210726151646713"></p>
<p>这个方法有两个兄弟：</p>
<ul>
<li><code>elem.insertAdjacentText(where, text)</code> — 语法一样，但是将 <code>text</code> 字符串“作为文本”插入而不是作为 HTML，</li>
<li><code>elem.insertAdjacentElement(where, elem)</code> — 语法一样，但是插入的是一个元素。</li>
</ul>
<p>它们的存在主要是为了使语法“统一”。实际上，大多数时候只使用 <code>insertAdjacentHTML</code>。因为对于元素和文本，我们有 <code>append/prepend/before/after</code> 方法 — 它们也可以用于插入节点/文本片段，但写起来更短。</p>
<h4 id="3-节点移除"><a href="#3-节点移除" class="headerlink" title="3. 节点移除"></a>3. 节点移除</h4><p>想要移除一个节点，可以使用 <code>node.remove()</code>。</p>
<p>请注意：如果我们要将一个元素 <strong>移动</strong> 到另一个地方，则无需将其从原来的位置中删除。</p>
<p><strong>所有插入方法都会自动从旧位置删除该节点。</strong></p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;first&quot;</span>&gt;</span>First<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;second&quot;</span>&gt;</span>Second<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript">    <span class="hljs-comment">// 无需调用 remove</span></span>
<span class="language-javascript">    second.<span class="hljs-title function_">after</span>(first); <span class="hljs-comment">// 获取 #second，并在其后面插入 #first</span></span>
<span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>

<h4 id="4-克隆节点"><a href="#4-克隆节点" class="headerlink" title="4. 克隆节点"></a>4. 克隆节点</h4><p>调用 <code>elem.cloneNode(true)</code> 来创建元素的一个“深”克隆 — 具有所有特性（attribute）和子元素。如果我们调用 <code>elem.cloneNode(false)</code>，那克隆就不包括子元素。</p>
<h4 id="5-DocumentFragment"><a href="#5-DocumentFragment" class="headerlink" title="5. DocumentFragment"></a>5. DocumentFragment</h4><p><code>DocumentFragment</code> 是一个特殊的 DOM 节点，用作来传递节点列表的包装器（wrapper）。我们可以向其附加其他节点，但是当我们将其插入某个位置时，则会插入其内容。</p>
<p>// TODO，感觉没什么用</p>
<h4 id="6-过时的insert-remove方法"><a href="#6-过时的insert-remove方法" class="headerlink" title="6. 过时的insert/remove方法"></a>6. 过时的insert/remove方法</h4><p><code>parentElem.appendChild(node)</code>：将 <code>node</code> 附加为 <code>parentElem</code> 的最后一个子元素。</p>
<p><code>parentElem.insertBefore(node, nextSibling)</code>：在 <code>parentElem</code> 的 <code>nextSibling</code> 前插入 <code>node</code>。</p>
<p><code>parentElem.replaceChild(node, oldChild)</code>：将 <code>parentElem</code> 的后代中的 <code>oldChild</code> 替换为 <code>node</code>。</p>
<p><code>parentElem.removeChild(node)</code>：从 <code>parentElem</code> 中删除 <code>node</code>（假设 <code>node</code> 为 <code>parentElem</code> 的后代）。</p>
<h4 id="7-document-write"><a href="#7-document-write" class="headerlink" title="7. document.write"></a>7. document.write</h4><p>同样，这也是一种过时的方法。这个方法适用于页面解析前，如果在页面解析后那么就会覆盖所有内容。因为它不涉及修改DOM，所以运行速度出奇的快</p>
<h3 id="1-8-样式和类"><a href="#1-8-样式和类" class="headerlink" title="1.8 样式和类"></a>1.8 样式和类</h3><p>通常有两种设置元素样式的方式：</p>
<ol>
<li>在 CSS 中创建一个类，并添加它：<code>&lt;div class=&quot;...&quot;&gt;</code></li>
<li>将属性直接写入 <code>style</code>：<code>&lt;div style=&quot;...&quot;&gt;</code>。</li>
</ol>
<p>相较于style的方式，我们更加倾向于class的方式，只有当class无法处理的时候我们才会选择style。</p>
<h4 id="1-className和classList"><a href="#1-className和classList" class="headerlink" title="1. className和classList"></a>1. className和classList</h4><p>更改类时JS中十分常见的操作，由于class即使DOM的属性又是JS的保留字，所以在很久以前，class不能作为对象的属性，但是现在这个限制不存在了。正是由于这远古的原因在引入了className。</p>
<p>如果我们对className进行赋值，它会替换类中的整个字符串。</p>
<p><code>elem.classList</code> 是一个特殊的对象（可迭代），它具有 <code>add/remove/toggle</code> 单个类的方法。</p>
<p><code>classList</code> 的方法：</p>
<ul>
<li><code>elem.classList.add/remove(class)</code> — 添加/移除类。</li>
<li><code>elem.classList.toggle(class)</code> — 如果类不存在就添加类，存在就移除它。</li>
<li><code>elem.classList.contains(class)</code> — 检查给定类，返回 <code>true/false</code>。</li>
</ul>
<h4 id="2-元素样式"><a href="#2-元素样式" class="headerlink" title="2. 元素样式"></a>2. 元素样式</h4><p>对于多词（multi-word）属性，使用驼峰式 camelCase，所有的短横线之后的字母都会被转为大写。</p>
<p>比如前缀属性：<code>-moz-border-radius</code> 它会被转为 <code>MozBorderRadius</code>。</p>
<h4 id="3-样式重置"><a href="#3-样式重置" class="headerlink" title="3. 样式重置"></a>3. 样式重置</h4><p>如果我们需要移除某一个样式，我们应该为其赋值为空字符串，不能选择删除属性。</p>
<p>注意 <code>style </code>对象是一个只读的，我们不能像赋值一样对其直接修改，想要以字符串的形式设置完整的样式，可以使用特殊属性 <code>style.cssText</code>。</p>
<h4 id="4-单位"><a href="#4-单位" class="headerlink" title="4. 单位"></a>4. 单位</h4><p>我们不应该将 <code>elem.style.top</code> 设置为 <code>10</code>，而应将其设置为 <code>10px</code>。否则设置会无效：</p>
<h4 id="5-计算样式"><a href="#5-计算样式" class="headerlink" title="5. 计算样式"></a>5. 计算样式</h4><p>上面讲述的是修改样式，如果读取嘞？这样吗？</p>
<pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">color</span></code></pre>

<p>这样是读取不出来的任何内容。这是因为：style 属性仅对 “style” 特性（attribute）值起作用，而没有任何 CSS 级联（cascade）。</p>
<p>读取的正确姿势：</p>
<pre><code class="hljs js"><span class="hljs-title function_">getComputedStyle</span>(element, [pseudo])</code></pre>

<ul>
<li><code>element</code>：需要被读取样式值的元素。</li>
<li><code>pseudo</code>：伪元素（如果需要），例如 <code>::before</code>。空字符串或无参数则意味着元素本身。</li>
</ul>
<hr>
<ol>
<li><strong>计算 (computed)</strong> 样式值是所有 CSS 规则和 CSS 继承都应用后的值，这是 CSS 级联（cascade）的结果。它看起来像 <code>height:1em</code> 或 <code>font-size:125%</code>。</li>
<li><strong>解析 (resolved)</strong> 样式值是最终应用于元素的样式值值。诸如 <code>1em</code> 或 <code>125%</code> 这样的值是相对的。浏览器将使用计算（computed）值，并使所有单位均为固定的，且为绝对单位，例如：<code>height:20px</code> 或 <code>font-size:16px</code>。对于几何属性，解析（resolved）值可能具有浮点，例如：<code>width:50.5px</code>。</li>
</ol>
<blockquote>
<p>可以使用 CSS 伪类 <code>:visited</code> 对被访问过的链接进行着色。但 <code>getComputedStyle</code> 没有给出访问该颜色的方式，因为如果给出了，那么就可以通过检查样式来确定用户是否访问了某个链接。此外，在CSS中也有类似的限制，即禁止在 <code>:visited</code> 中应用更改几何形状的样式。这是为了确保一个不好的页面无法测试链接是否被访问，进而窥探隐私。</p>
</blockquote>
<h3 id="1-9-元素大小和滚动"><a href="#1-9-元素大小和滚动" class="headerlink" title="1.9 元素大小和滚动"></a>1.9 元素大小和滚动</h3><p>// TODO</p>
<h3 id="1-10-Window大小和滚动"><a href="#1-10-Window大小和滚动" class="headerlink" title="1.10 Window大小和滚动"></a>1.10 Window大小和滚动</h3><p>// TODO</p>
<h3 id="1-11-坐标"><a href="#1-11-坐标" class="headerlink" title="1.11 坐标"></a>1.11 坐标</h3><h2 id="2-事件"><a href="#2-事件" class="headerlink" title="2. 事件"></a>2. 事件</h2><p><strong>鼠标事件</strong></p>
<ul>
<li><code>click</code> —— 当鼠标点击一个元素时（触摸屏设备会在点击时生成）。</li>
<li><code>contextmenu</code> —— 当鼠标右键点击一个元素时。</li>
<li><code>mouseover</code> / <code>mouseout</code> —— 当鼠标指针移入/离开一个元素时。</li>
<li><code>mousedown</code> / <code>mouseup</code> —— 当在元素上按下/释放鼠标按钮时。</li>
<li><code>mousemove</code> —— 当鼠标移动时。</li>
</ul>
<p><strong>键盘事件</strong></p>
<ul>
<li><code>keydown</code> 和 <code>keyup</code> —— 当按下和松开一个按键时。</li>
</ul>
<p><strong>表单（form）元素事件</strong>：</p>
<ul>
<li><code>submit</code> —— 当访问者提交了一个 <code>&lt;form&gt;</code> 时。</li>
<li><code>focus</code> —— 当访问者聚焦于一个元素时，例如聚焦于一个 <code>&lt;input&gt;</code>。</li>
</ul>
<p><strong>Document 事件</strong>：</p>
<ul>
<li><code>DOMContentLoaded</code> —— 当 HTML 的加载和处理均完成，DOM 被完全构建完成时。</li>
</ul>
<p><strong>CSS 事件</strong>：</p>
<ul>
<li><code>transitionend</code> —— 当一个 CSS 动画完成时。</li>
</ul>
<h3 id="2-1-事件简介"><a href="#2-1-事件简介" class="headerlink" title="2.1. 事件简介"></a>2.1. 事件简介</h3><h4 id="1-事件处理器"><a href="#1-事件处理器" class="headerlink" title="1. 事件处理器"></a>1. 事件处理器</h4><p><strong>HTML特性</strong></p>
<p>处理程序可以设置在 HTML 中名为 <code>on&lt;event&gt;</code> 的特性（attribute）中。</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Click me&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;Click!&#x27;)&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span></code></pre>

<p><strong>DOM属性</strong></p>
<p>我们可以使用 DOM 属性（property）<code>on&lt;event&gt;</code> 来分配处理程序。</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;elem&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Click me&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript">    elem.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span>
<span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Thank you&#x27;</span>);</span>
<span class="language-javascript">    &#125;;</span>
<span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>

<h4 id="2-访问元素：this"><a href="#2-访问元素：this" class="headerlink" title="2. 访问元素：this"></a>2. 访问元素：this</h4><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(this.innerHTML)&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre>

<h4 id="3-可能出现的错误"><a href="#3-可能出现的错误" class="headerlink" title="3. 可能出现的错误"></a>3. 可能出现的错误</h4><p>在HTML特性进行事件处理时，注意函数具有括号。</p>
<p>如果我们使用 <code>setAttribute</code> 的方式，注意下面的方式时错误的：</p>
<pre><code class="hljs js"><span class="hljs-comment">// 点击 &lt;body&gt; 将产生 error，</span>
<span class="hljs-comment">// 因为特性总是字符串的，函数变成了一个字符串</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;onclick&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-title function_">alert</span>(<span class="hljs-number">1</span>) &#125;);</code></pre>

<h4 id="4-addEventListener"><a href="#4-addEventListener" class="headerlink" title="4. addEventListener"></a>4. addEventListener</h4><p>上面的处理方式的根本问题是，我们不能为一个事件分配多个处理程序。</p>
<p>Web 标准的开发者很早就了解到了这一点，并提出了一种使用特殊方法 <code>addEventListener</code> 和 <code>removeEventListener</code> 来管理处理程序的替代方法。它们没有这样的问题。</p>
<pre><code class="hljs js">element.<span class="hljs-title function_">addEventListener</span>(event, handler[, options]);</code></pre>

<ul>
<li><p><code>event</code></p>
<p>  事件名，例如：<code>&quot;click&quot;</code>。</p>
</li>
<li><p><code>handler</code></p>
<p>  处理程序。</p>
</li>
<li><p><code>options</code></p>
<p>  具有以下属性的附加可选对象：<code>once</code>：如果为 <code>true</code>，那么会在被触发后自动删除监听器。<code>capture</code>：事件处理的阶段，我们稍后将在 <a href="https://zh.javascript.info/bubbling-and-capturing">冒泡和捕获</a> 一章中介绍。由于历史原因，<code>options</code> 也可以是 <code>false/true</code>，它与 <code>&#123;capture: false/true&#125;</code> 相同。<code>passive</code>：如果为 <code>true</code>，那么处理程序将不会调用 <code>preventDefault()</code>，我们稍后将在 <a href="https://zh.javascript.info/default-browser-action">浏览器默认行为</a> 一章中介绍。</p>
</li>
</ul>
<p>要移除处理程序，可以使用 <code>removeEventListener</code>：</p>
<pre><code class="hljs js">element.<span class="hljs-title function_">removeEventListener</span>(event, handler[, options]);</code></pre>

<p>移除需要相同的函数：</p>
<p>如果传入的函数引用不同，那么就算传入的内容相同，也无法进行正确的移除，所以需要将函数存储在一个变量中。</p>
<blockquote>
<p>我们可以同时使用 DOM 属性和 <code>addEventListener</code> 来设置处理程序。但通常我们只使用其中一种方式。</p>
</blockquote>
<p>对于某些事件，只能通过<code>addEventListener</code> 设置处理程序。比如：<code>DOMContentLoaded</code>。</p>
<p>如果某个元素添加了多个监听器，那么事件的响应顺序和设置顺序相同。</p>
<h4 id="5-事件对象"><a href="#5-事件对象" class="headerlink" title="5. 事件对象"></a>5. 事件对象</h4><p>当事件发生时，浏览器会创建一个 <code>event 对象</code>，将详细信息放入其中，并将其作为参数传递给处理程序。</p>
<ul>
<li><code>event.type</code><br>  事件类型，比如 “click”。</li>
<li><code>event.currentTarget</code><br>  处理事件的元素。这与 this 相同，除非处理程序是一个箭头函数，或者它的 this 被绑定到了其他东西上，之后我们就可以从event.currentTarget 获取元素了。</li>
<li><code>event.clientX / event.clientY</code><br>  指针事件（pointer event）的指针的窗口相对坐标。</li>
</ul>
<p>HTML特性方式也可以。</p>
<h4 id="6-对象处理程序"><a href="#6-对象处理程序" class="headerlink" title="6. 对象处理程序"></a>6. 对象处理程序</h4><p>上面我们都是为事件处理器分配一个函数，实际上我们也可以分配一个对象，当事件发生时就会调用该对象的 <code>handleEvent</code> 方法。</p>
<h3 id="2-2-冒泡和捕获"><a href="#2-2-冒泡和捕获" class="headerlink" title="2.2. 冒泡和捕获"></a>2.2. 冒泡和捕获</h3><p>当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序。</p>
<p>几乎所有的事件都会冒泡，但是也有例外，例如 <code>focus</code></p>
<h4 id="1-event-target"><a href="#1-event-target" class="headerlink" title="1. event.target"></a>1. event.target</h4><p>父元素上的处理程序始终可以获取事件实际发生位置的详细信息。</p>
<p>引发事件的那个嵌套层级最深的元素被称为目标元素,可以通过 event.target 访问。</p>
<p>注意与 <code>this</code>（=<code>event.currentTarget</code>）之间的区别：</p>
<ul>
<li><code>event.target</code> —— 是引发事件的“目标”元素，它在冒泡过程中不会发生变化。</li>
<li><code>this</code> —— 是“当前”元素，其中有一个当前正在运行的处理程序。</li>
</ul>
<h4 id="2-停止冒泡"><a href="#2-停止冒泡" class="headerlink" title="2. 停止冒泡"></a>2. 停止冒泡</h4><p>用于停止冒泡的方法是 <code>event.stopPropagation()</code>，但是这只能停止一个。<code>event.stopImmediatePropagation()</code>，可以让所有事件停止冒泡。</p>
<blockquote>
<p>不要在没有需要的的情况下停止冒泡</p>
</blockquote>
<h4 id="3-捕获"><a href="#3-捕获" class="headerlink" title="3. 捕获"></a>3. 捕获</h4><p><a href="http://www.w3.org/TR/DOM-Level-3-Events/">DOM 事件</a>标准描述了事件传播的 3 个阶段：</p>
<ol>
<li>捕获阶段（Capturing phase）—— 事件（从 Window）向下走近元素。</li>
<li>目标阶段（Target phase）—— 事件到达目标元素。</li>
<li>冒泡阶段（Bubbling phase）—— 事件从元素上开始冒泡。</li>
</ol>
<p>为了在捕获阶段捕获事件，我们需要将处理程序的 <code>capture</code> 选项设置为 <code>true</code>：</p>
<pre><code class="hljs js">elem.<span class="hljs-title function_">addEventListener</span>(..., &#123;<span class="hljs-attr">capture</span>: <span class="hljs-literal">true</span>&#125;)
<span class="hljs-comment">// 或者，用 &#123;capture: true&#125; 的别名 &quot;true&quot;</span>
elem.<span class="hljs-title function_">addEventListener</span>(..., <span class="hljs-literal">true</span>)</code></pre>

<p><code>capture</code> 选项有两个可能的值：</p>
<ul>
<li>如果为 <code>false</code>（默认值），则在冒泡阶段设置处理程序。</li>
<li>如果为 <code>true</code>，则在捕获阶段设置处理程序。</li>
</ul>
<h3 id="2-3-事件委托"><a href="#2-3-事件委托" class="headerlink" title="2.3 事件委托"></a>2.3 事件委托</h3><p>如果我们有许多以类似方式处理的元素，那么就不必为每个元素分配一个处理程序 —— 而是将单个处理程序放在它们的共同祖先上。</p>
<p><img src="C:\Users\twowind\AppData\Roaming\Typora\typora-user-images\image-20210727093250916.png" alt="image-20210727093250916"></p>
<p>在这样一个图中，如果想实现点击某一个格子，从而使该格子高亮，我们不必为每个格子添加事件，只需要为外层的table添加一个事件处理器，再根据传入的 event 对象判断是哪一个格子。但是问题在于，如果我们点击不是该格子，而是里面的元素（如文本），这时我们可以使用 <code>closest</code> 来寻找最近的td。</p>
<p>为什么我们需要事件委托，正如上面的例子中，如果格子变多，那么由于每个格子都需要创建对应的对象进行事件处理，创建的对象越多，页面的性能就越差，使用事件委托，我们可以极大的减少对象创建。</p>
<blockquote>
<p>事件委托的原理就是利用事件冒泡。</p>
</blockquote>
<h4 id="1-委托示例：标记中的行为"><a href="#1-委托示例：标记中的行为" class="headerlink" title="1. 委托示例：标记中的行为"></a>1. 委托示例：标记中的行为</h4><p>当我们需要为三个按钮分配三个不同的事件，可能最先想到的就是依次设置点击事件，但是有一个更优雅的解决方案。我们可以为整个菜单添加一个处理程序。</p>
<p>// TODO</p>
<h4 id="2-“行为”模式"><a href="#2-“行为”模式" class="headerlink" title="2. “行为”模式"></a>2. “行为”模式</h4><p>行为模式分为两个部分：</p>
<ol>
<li>我们将自定义特性添加到描述其行为的元素。</li>
<li>用<code>文档范围级</code>的处理程序追踪事件，如果事件发生在具有特定特性的元素上 —— 则执行行为（action）。</li>
</ol>
<p><strong>计数器</strong></p>
<pre><code class="hljs html">Counter: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">data-counter</span>&gt;</span>
One more counter: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">data-counter</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;</span>
<span class="language-javascript"></span>
<span class="language-javascript">        <span class="hljs-keyword">if</span> (event.<span class="hljs-property">target</span>.<span class="hljs-property">dataset</span>.<span class="hljs-property">counter</span> != <span class="hljs-literal">undefined</span>) &#123; <span class="hljs-comment">// 如果这个特性存在...</span></span>
<span class="language-javascript">            event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>++;</span>
<span class="language-javascript">        &#125;</span>
<span class="language-javascript"></span>
<span class="language-javascript">    &#125;);</span>
<span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>

<p>代码中，为整个document设置事件，点击其子元素且包含设置的特性，则触发修改，事件能够响应的根本原理就是事件冒泡，而 target始终指向的是 点击的元素。</p>
<p><strong>切换器</strong></p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">data-toggle-id</span>=<span class="hljs-string">&quot;subscribe-mail&quot;</span>&gt;</span>
    Show the subscription form
<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;subscribe-mail&quot;</span> <span class="hljs-attr">hidden</span>&gt;</span>
    Your mail: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;</span>
<span class="language-javascript">        <span class="hljs-keyword">let</span> id = event.<span class="hljs-property">target</span>.<span class="hljs-property">dataset</span>.<span class="hljs-property">toggleId</span>;</span>
<span class="language-javascript">        <span class="hljs-keyword">if</span> (!id) <span class="hljs-keyword">return</span>;</span>
<span class="language-javascript"></span>
<span class="language-javascript">        <span class="hljs-keyword">let</span> elem = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(id);</span>
<span class="language-javascript"></span>
<span class="language-javascript">        elem.<span class="hljs-property">hidden</span> = !elem.<span class="hljs-property">hidden</span>;</span>
<span class="language-javascript">    &#125;);</span>
<span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>

<h3 id="2-4-浏览器默认行为"><a href="#2-4-浏览器默认行为" class="headerlink" title="2.4 浏览器默认行为"></a>2.4 浏览器默认行为</h3><p>许多事件会自动触发浏览器执行某些行为。</p>
<p>例如：</p>
<ul>
<li>点击一个链接 —— 触发导航（navigation）到该 URL。</li>
<li>点击表单的提交按钮 —— 触发提交到服务器的行为。</li>
<li>在文本上按下鼠标按钮并移动 —— 选中文本。</li>
</ul>
<p>有时候我们希望使用浏览器不去执行这些默认行为，或者替换成自己的处理程序。</p>
<h4 id="1-阻止浏览器行为"><a href="#1-阻止浏览器行为" class="headerlink" title="1. 阻止浏览器行为"></a>1. 阻止浏览器行为</h4><ul>
<li>主流的方式是使用 <code>event</code> 对象。有一个 <code>event.preventDefault()</code> 方法。</li>
<li>如果处理程序是使用 <code>on&lt;event&gt;</code>（而不是 <code>addEventListener</code>）分配的，那返回 <code>false</code> 也同样有效。其它情况返回没有意义。</li>
</ul>
<h4 id="2-处理程序选项“passive”"><a href="#2-处理程序选项“passive”" class="headerlink" title="2. 处理程序选项“passive”"></a>2. 处理程序选项“passive”</h4><p>浏览器的默认行为通常发生在处理程序处理后，但是这样就会造成不必要的<code>延迟</code>和<code>抖动</code>。</p>
<p><code>addEventListener</code> 的可选项 <code>passive: true</code> 向浏览器发出信号，表明处理程序将不会调用 <code>preventDefault()</code>。</p>
<h4 id="3-event-defaultPrevented"><a href="#3-event-defaultPrevented" class="headerlink" title="3. event.defaultPrevented"></a>3. event.defaultPrevented</h4><p>如果默认行为被阻止，那么 <code>event.defaultPrevented</code> 属性为 <code>true</code>，否则为 <code>false</code>。</p>
<h3 id="2-5-创建自定义事件"><a href="#2-5-创建自定义事件" class="headerlink" title="2.5 创建自定义事件"></a>2.5 创建自定义事件</h3><h4 id="1-事件构造器"><a href="#1-事件构造器" class="headerlink" title="1. 事件构造器"></a>1. 事件构造器</h4><p>内建事件类形成一个层次结构（hierarchy），类似于 DOM 元素类。根是内建的 <a href="http://www.w3.org/TR/dom/#event">Event</a> 类。</p>
<p>我们可以像这样创建 <code>Event</code> 对象：</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">let</span> event = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Event</span>(type[, options]);</code></pre>

<p>参数：</p>
<ul>
<li><p><strong>type</strong> —— 事件类型，可以是像这样 <code>&quot;click&quot;</code> 的字符串，或者我们自己的像这样 <code>&quot;my-event&quot;</code> 的参数。</p>
</li>
<li><p><strong>options</strong> —— 具有两个可选属性的对象：</p>
<ul>
<li><code>bubbles: true/false</code> —— 如果为 <code>true</code>，那么事件会冒泡。</li>
<li><code>cancelable: true/false</code> —— 如果为 <code>true</code>，那么“默认行为”就会被阻止。稍后我们会看到对于自定义事件，它意味着什么。</li>
</ul>
<p>  默认情况下，以上两者都为 false：<code>&#123;bubbles: false, cancelable: false&#125;</code>。</p>
</li>
</ul>
<h4 id="2-dispatchEvent"><a href="#2-dispatchEvent" class="headerlink" title="2. dispatchEvent"></a>2. dispatchEvent</h4><p>事件对象被创建后，我们应该使用 <code>elem.dispatchEvent(event)</code> 调用在元素上“运行”它。</p>
<p><strong>event.isTrusted</strong></p>
<p>有一种方法可以区分“真实”用户事件和通过脚本生成的事件。</p>
<p>对于来自真实用户操作的事件，<code>event.isTrusted</code> 属性为 <code>true</code>，对于脚本生成的事件，<code>event.isTrusted</code> 属性为 <code>false</code>。</p>
<h4 id="3-Event子类"><a href="#3-Event子类" class="headerlink" title="3. Event子类"></a>3. Event子类</h4><p>这是一个摘自于 <a href="https://www.w3.org/TR/uievents">UI 事件规范</a> 的一个简短的 UI 事件类列表：</p>
<ul>
<li><code>UIEvent</code></li>
<li><code>FocusEvent</code></li>
<li><code>MouseEvent</code></li>
<li><code>WheelEvent</code></li>
<li><code>KeyboardEvent</code></li>
<li>…</li>
</ul>
<h4 id="4-自定义事件"><a href="#4-自定义事件" class="headerlink" title="4. 自定义事件"></a>4. 自定义事件</h4><p>Event对象的第二个参数，除了一些可选项，还可以自定义一些属性，理论上讲我们可以创建任何属性，但是 <code>CustomEvent</code> 提供了特殊的 <code>detail</code> 字段，以避免与其他事件属性的冲突。</p>
<h4 id="5-preventDefault"><a href="#5-preventDefault" class="headerlink" title="5. preventDefault()"></a>5. preventDefault()</h4><p>如果自定义的事件被 preventDefault 那么当我们调用 dispatchEvent(event) 就会返回一个false的结果。</p>
<h4 id="6-事件中的事件是同步的"><a href="#6-事件中的事件是同步的" class="headerlink" title="6. 事件中的事件是同步的"></a>6. 事件中的事件是同步的</h4><p>通常事件是在队列中处理的。一般来说，当有在执行一个事件的时候，如果另一个事件被触发，那么第二个事件就会排入队列中，只有等待第一个事件执行完之后，第二个事件才会进行处理。</p>
<p>值得注意的例外情况就是，一个事件是在另一个事件中发起的。例如使用 <code>dispatchEvent</code>。这类事件将会被立即处理，即在新的事件处理程序被调用之后，恢复到当前的事件处理程序。如果我们就像让事件顺序执行，可以将被调用的事件放在事件处理器的末尾行，或者使用一个定时函数。</p>
<h2 id="3-UI事件"><a href="#3-UI事件" class="headerlink" title="3. UI事件"></a>3. UI事件</h2><h3 id="3-1-鼠标事件"><a href="#3-1-鼠标事件" class="headerlink" title="3.1 鼠标事件"></a>3.1 鼠标事件</h3><h4 id="1-鼠标事件类型"><a href="#1-鼠标事件类型" class="headerlink" title="1. 鼠标事件类型"></a>1. 鼠标事件类型</h4><ul>
<li><code>mousedown/mouseup</code><br>  在元素上点击/释放鼠标按钮。</li>
<li><code>mouseover/mouseout</code><br>  鼠标指针从一个元素上移入/移出。</li>
<li><code>mousemove</code><br>  鼠标在元素上的每个移动都会触发此事件。</li>
<li><code>click</code><br>  如果使用的是鼠标左键，则在同一个元素上的 mousedown 及 mouseup 相继触发后，触发该事件。</li>
<li><code>dblclick</code><br>  在短时间内双击同一元素后触发。如今已经很少使用了。</li>
<li><code>contextmenu</code><br>  在鼠标右键被按下时触发。还有其他打开上下文菜单的方式，例如使用特殊的键盘按键，在这种情况下它也会被触发，因此它并不完全是鼠标事件。</li>
</ul>
<p>由于 click和contextmenu都会先引起 mousedown 和 mouseup 事件。我们可以通过 <code>event.button</code> 的值来进行区分是左击还是右击。</p>
<p><code>event.button</code> 的所有可能值如下：</p>
<table>
<thead>
<tr>
<th align="left">鼠标按键状态</th>
<th align="left"><code>event.button</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left">左键 (主要按键)</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">中键 (辅助按键)</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">右键 (次要按键)</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">X1 键 (后退按键)</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">X2 键 (前进按键)</td>
<td align="left">4</td>
</tr>
</tbody></table>
<p>另外，还有一个 <code>event.buttons</code> 属性，其中以整数的形式存储着当前所有按下的鼠标按键，每个按键一个比特位。在实际开发中，很少会用到这个属性，如果有需要的话，你可以在 <a href="https://developer.mozilla.org/zh/docs/Web/api/MouseEvent/buttons">MDN</a> 中找到更多细节。</p>
<p><strong>event.which</strong></p>
<p>一些老代码可能会使用 <code>event.which</code> 属性来获得按下的按键。这是一个古老的非标准的方式，具有以下可能值：</p>
<ul>
<li><code>event.which == 1</code> —— 鼠标左键，</li>
<li><code>event.which == 2</code> —— 鼠标中键，</li>
<li><code>event.which == 3</code> —— 鼠标右键。</li>
</ul>
<p>现在，<code>event.which</code> 已经被弃用了，不应再使用它。</p>
<h4 id="2-组合键：shift-alt-ctrl-meta"><a href="#2-组合键：shift-alt-ctrl-meta" class="headerlink" title="2. 组合键：shift, alt, ctrl, meta"></a>2. 组合键：shift, alt, ctrl, meta</h4><p>所有的鼠标事件都包含有关按下的组合键的信息。</p>
<p>事件属性：</p>
<ul>
<li><code>shiftKey</code>：Shift</li>
<li><code>altKey</code>：Alt（或对于 Mac 是 Opt）</li>
<li><code>ctrlKey</code>：Ctrl</li>
<li><code>metaKey</code>：对于 Mac 是 Cmd</li>
</ul>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>Alt+Shift+Click on me!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript">    button.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;</span>
<span class="language-javascript">        <span class="hljs-keyword">if</span> (event.<span class="hljs-property">altKey</span> &amp;&amp; event.<span class="hljs-property">shiftKey</span>) &#123;</span>
<span class="language-javascript">            <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hooray!&#x27;</span>);</span>
<span class="language-javascript">        &#125;</span>
<span class="language-javascript">    &#125;;</span>
<span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>

<p><strong>Mac</strong></p>
<p>在Mac设备上，我们通常使用 <code>cmd</code> 代替 <code>ctrl</code> ，尽管mac上有 ctrl 但是 ctrl 键和其它键组合可能会有其它快捷方式，比如 Ctrl+click 在mac上会解释成 contextmenu。这就导致我们的程序在事件检查时，应该是<code> if (event.ctrlKey || event.metaKey)</code></p>
<p><strong>移动设备</strong></p>
<p>键盘组合式工作流的一个补充，通常在移动设备中，除非有外置键盘否则快捷方式都会失效，所以我们必须考虑没有快捷方式的情况。</p>
<h4 id="3-坐标"><a href="#3-坐标" class="headerlink" title="3. 坐标"></a>3. 坐标</h4><p>所有的鼠标事件都提供了两种形式的坐标：</p>
<ol>
<li>相对于窗口的坐标：<code>clientX</code> 和 <code>clientY</code>。随着页面滚动而改变。</li>
<li>相对于文档的坐标：<code>pageX</code> 和 <code>pageY</code>。不会随着页面滚动而改变。</li>
</ol>
<h4 id="4-防止在鼠标按下时的选择"><a href="#4-防止在鼠标按下时的选择" class="headerlink" title="4. 防止在鼠标按下时的选择"></a>4. 防止在鼠标按下时的选择</h4><p>双击鼠标会有副作用，在某些界面中可能会出现干扰：它会选择文本。我们可以使用阻止默认事件。</p>
<p><strong>防止复制</strong></p>
<p>可以在 oncopy 事件中阻止默认事件。</p>
<h3 id="3-2-鼠标移动"><a href="#3-2-鼠标移动" class="headerlink" title="3.2 鼠标移动"></a>3.2 鼠标移动</h3><h4 id="1-mouseover-mouseout"><a href="#1-mouseover-mouseout" class="headerlink" title="1. mouseover/mouseout"></a>1. mouseover/mouseout</h4><p><img src="https://i.loli.net/2021/07/27/ohgzxrCtOsDmASZ.png" alt="image-20210727140736451"></p>
<p>对于这两个事件，它的event对象有一个特殊的属性 <code>relatedTarget</code> ，此属性是对 <code>target</code> 的补充。我们只需要记住，无论是mouseover还是mouseouttarget事件，其target都是上图的div，至于 relatedTarget ，如果 mouseover 事件，那么 relatedTarget 是移入前的元素，相对的，mouseout 则是移到的那个元素。如果 relatedTarget 说明移入前在窗口外，或者移动到窗口外。</p>
<h4 id="2-跳过元素"><a href="#2-跳过元素" class="headerlink" title="2. 跳过元素"></a>2. 跳过元素</h4><p>当我们移动的鼠标过快是，是有可能跳过某些元素，这听起来有些像“称它不注意”，其实这是一个对性能有好处的，因为当我们移动到目标元素时中间时，我们并不是想要检查每一个移入和移除的过程。</p>
<blockquote>
<p>但是有一点我们需要注意，如果 mouseover 被触发了，那么 mouseout 也一定会被触发。</p>
</blockquote>
<h4 id="3-mouseenter-mouseleave"><a href="#3-mouseenter-mouseleave" class="headerlink" title="3. mouseenter/mouseleave"></a>3. mouseenter/mouseleave</h4><p>事件 <code>mouseenter/mouseleave</code> 类似于 <code>mouseover/mouseout</code>。它们在鼠标指针进入/离开元素时触发。</p>
<p>但是有两个重要的区别：</p>
<ol>
<li>元素内部与后代之间的转换不会产生影响。</li>
<li>事件 <code>mouseenter/mouseleave</code> 不会冒泡。</li>
</ol>
<p>所谓不会冒泡，即当从父元素移入到子元素时，则不会识别为鼠标的移入移出。</p>
<h4 id="4-事件委托"><a href="#4-事件委托" class="headerlink" title="4. 事件委托"></a>4. 事件委托</h4><p>由于事件 <code>mouseenter/mouseleave</code> 不会冒泡，因此我们不能使用它们进行事件委托</p>
<h3 id="3-3-鼠标拖放事件"><a href="#3-3-鼠标拖放事件" class="headerlink" title="3.3 鼠标拖放事件"></a>3.3 鼠标拖放事件</h3><p>在现代 HTML 标准中有一个 <a href="https://html.spec.whatwg.org/multipage/interaction.html#dnd">关于拖放的部分</a>，其中包含了例如 <code>dragstart</code> 和 <code>dragend</code> 等特殊事件。</p>
<h4 id="1-拖放算法"><a href="#1-拖放算法" class="headerlink" title="1. 拖放算法"></a>1. 拖放算法</h4><ol>
<li>在 <code>mousedown</code> 上 —— 根据需要准备要移动的元素（也许创建一个它的副本，向其中添加一个类或其他任何东西）。</li>
<li>然后在 <code>mousemove</code> 上，通过更改 <code>position:absolute</code> 情况下的 <code>left/top</code> 来移动它。</li>
<li>在 <code>mouseup</code> 上 —— 执行与完成的拖放相关的所有行为。</li>
</ol>
<blockquote>
<p>注意拖动是具有默认事件的，比如如果拖动图片会出现禁止拖动的效果。</p>
</blockquote>
<p>// TODO</p>
<h3 id="3-4-指针事件"><a href="#3-4-指针事件" class="headerlink" title="3.4 指针事件"></a>3.4 指针事件</h3><p>最开始的时候只有鼠标事件，但是随着智能机的普及出现了多点触摸，这时候鼠标事件无法满足我们的要求了，现在更是有触控笔等等，它们都有属于自己的特性，如果每一个都进行维护就显得有些笨重了。这时候引入了指针事件，它为各种指针输入设备提供了一套统一的事件。</p>
<h4 id="1-指针事件类型"><a href="#1-指针事件类型" class="headerlink" title="1. 指针事件类型"></a>1. 指针事件类型</h4><p>指针事件的命名方式和鼠标事件类似：</p>
<table>
<thead>
<tr>
<th align="left">指针事件</th>
<th align="left">类似的鼠标事件</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>pointerdown</code></td>
<td align="left"><code>mousedown</code></td>
</tr>
<tr>
<td align="left"><code>pointerup</code></td>
<td align="left"><code>mouseup</code></td>
</tr>
<tr>
<td align="left"><code>pointermove</code></td>
<td align="left"><code>mousemove</code></td>
</tr>
<tr>
<td align="left"><code>pointerover</code></td>
<td align="left"><code>mouseover</code></td>
</tr>
<tr>
<td align="left"><code>pointerout</code></td>
<td align="left"><code>mouseout</code></td>
</tr>
<tr>
<td align="left"><code>pointerenter</code></td>
<td align="left"><code>mouseenter</code></td>
</tr>
<tr>
<td align="left"><code>pointerleave</code></td>
<td align="left"><code>mouseleave</code></td>
</tr>
<tr>
<td align="left"><code>pointercancel</code></td>
<td align="left">-</td>
</tr>
<tr>
<td align="left"><code>gotpointercapture</code></td>
<td align="left">-</td>
</tr>
<tr>
<td align="left"><code>lostpointercapture</code></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>我们可以把代码中的 <code>mouse&lt;event&gt;</code> 都替换成 <code>pointer&lt;event&gt;</code>，程序仍然正常兼容鼠标设备。</p>
<h4 id="2-指针事件属性"><a href="#2-指针事件属性" class="headerlink" title="2. 指针事件属性"></a>2. 指针事件属性</h4><p>指针事件具备和鼠标事件完全相同的属性，包括 <code>clientX/Y</code> 和 <code>target</code> 等，以及一些其他属性：</p>
<ul>
<li><p><code>pointerId</code> —— 触发当前事件的指针唯一标识符。</p>
<p>  浏览器生成的。使我们能够处理多指针的情况，例如带有触控笔和多点触控功能的触摸屏（下文会有相关示例）。</p>
</li>
<li><p><code>pointerType</code> —— 指针的设备类型。必须为字符串，可以是：“mouse”、“pen” 或 “touch”。</p>
<p>  我们可以使用这个属性来针对不同类型的指针输入做出不同响应。</p>
</li>
<li><p><code>isPrimary</code> —— 当指针为首要指针（多点触控时按下的第一根手指）时为 <code>true</code>。</p>
</li>
</ul>
<p>有些指针设备会测量接触面积和点按压力（例如一根手指压在触屏上），对于这种情况可以使用以下属性：</p>
<ul>
<li><code>width</code> —— 指针（例如手指）接触设备的区域的宽度。对于不支持的设备（如鼠标），这个值总是 <code>1</code>。</li>
<li><code>height</code> —— 指针（例如手指）接触设备的区域的长度。对于不支持的设备，这个值总是 <code>1</code>。</li>
<li><code>pressure</code> —— 触摸压力，是一个介于 0 到 1 之间的浮点数。对于不支持压力检测的设备，这个值总是 <code>0.5</code>（按下时）或 <code>0</code>。</li>
<li><code>tangentialPressure</code> —— 归一化后的切向压力（tangential pressure）。</li>
<li><code>tiltX</code>, <code>tiltY</code>, <code>twist</code> —— 针对触摸笔的几个属性，用于描述笔和屏幕表面的相对位置。</li>
</ul>
<p>大多数设备都不支持这些属性，因此它们很少被使用。如果你需要使用它们，可以在 <a href="https://w3c.github.io/pointerevents/#pointerevent-interface">规范文档</a> 中查看更多有关它们的详细信息。</p>
<h4 id="3-多点触控"><a href="#3-多点触控" class="headerlink" title="3. 多点触控"></a>3. 多点触控</h4><p>多点触控（用户在手机或平板上同时点击若干个位置，或执行特殊手势）是鼠标事件完全不支持的功能之一。</p>
<ol>
<li>第一个手指触摸：<ul>
<li><code>pointerdown</code> 事件触发，<code>isPrimary=true</code>，并且被指派了一个 <code>pointerId</code>。</li>
</ul>
</li>
<li>第二个和后续的更多个手指触摸（假设第一个手指仍在触摸）：<ul>
<li><code>pointerdown</code> 事件触发，<code>isPrimary=false</code>，并且每一个触摸都被指派了不同的 <code>pointerId</code>。</li>
</ul>
</li>
</ol>
<h4 id="4-事件：pointercancel"><a href="#4-事件：pointercancel" class="headerlink" title="4. 事件：pointercancel"></a>4. 事件：pointercancel</h4><p><code>pointercancel</code> 事件将会在一个正处于活跃状态的指针交互由于某些原因被中断时触发。也就是在这个事件之后，该指针就不会继续触发更多事件了。</p>
<p>导致指针中断的可能原因如下：</p>
<ul>
<li>指针设备硬件在物理层面上被禁用。</li>
<li>设备方向旋转（例如给平板转了个方向）。</li>
<li>浏览器打算自行处理这一交互，比如将其看作是一个专门的鼠标手势或缩放操作等。</li>
</ul>
<p><strong>阻止浏览器的默认行为来防止 pointercancel 触发。</strong></p>
<p>我们需要做两件事：</p>
<ol>
<li>阻止原生的拖放操作发生：<ul>
<li>正如我们在 <a href="https://zh.javascript.info/mouse-drag-and-drop">鼠标拖放事件</a> 中描述的那样，我们可以通过设置 <code>ball.ondragstart = () =&gt; false</code> 来实现这一需求。</li>
<li>这种方式也适用于鼠标事件。</li>
</ul>
</li>
<li>对于触屏设备，还有其他和触摸相关的浏览器行为（除了拖放）。为了避免它们所引发的问题：<ul>
<li>我们可以通过在 CSS 中设置 <code>#ball &#123; touch-action: none &#125;</code> 来阻止它们。</li>
<li>之后我们的代码便可以在触屏设备中正常工作了。</li>
</ul>
</li>
</ol>
<h4 id="5-指针捕获"><a href="#5-指针捕获" class="headerlink" title="5. 指针捕获"></a>5. 指针捕获</h4><p><code>elem.setPointerCapture(pointerId)</code> —— 将给定的 <code>pointerId</code> 绑定到 <code>elem</code>。在调用之后，所有具有相同 <code>pointerId</code> 的指针事件都将 <code>elem</code> 作为目标（就像事件发生在 <code>elem</code> 上一样），无论这些 <code>elem</code> 在文档中的实际位置是什么。</p>
<p>绑定会在以下情况下被移除：</p>
<ul>
<li>当 <code>pointerup</code> 或 <code>pointercancel</code> 事件出现时，绑定会被自动地移除。</li>
<li>当 <code>elem</code> 被从文档中移除后，绑定会被自动地移除。</li>
<li>当 <code>elem.releasePointerCapture(pointerId)</code> 被调用，绑定会被移除。</li>
</ul>
<p>比如：元素块内有一个滑动拖块，当我们拖动时，如果拖到元素外，就会断开拖动事件，如果我们为整个document绑定拖动事件，那么就可能引起其它的元素的拖动函数。</p>
<p>指针捕获提供了一种将 <code>pointermove</code> 绑定到 <code>thumb</code> 并避免其他此类问题发生的方式：</p>
<ul>
<li>我们可以在 <code>pointerdown</code> 事件的处理程序中调用 <code>thumb.setPointerCapture(event.pointerId)</code>，</li>
<li>这样接下来在 <code>pointerup/cancel</code> 之前发生的所有指针事件都会被重定向到 <code>thumb</code> 上。</li>
<li>当 <code>pointerup</code> 发生时（拖动完成），绑定会被自动移除，我们不需要关心它。</li>
</ul>
<p>还有两个相关的指针捕获事件:</p>
<ul>
<li><code>gotpointercapture</code> 会在一个元素使用 <code>setPointerCapture</code> 来启用捕获后触发。</li>
<li><code>lostpointercapture</code> 会在捕获被释放后触发：其触发可能是由于 <code>releasePointerCapture</code> 的显式调用，或是 <code>pointerup</code>/<code>pointercancel</code> 事件触发后的自动调用。</li>
</ul>
<h3 id="3-5-键盘：keydown-keyup"><a href="#3-5-键盘：keydown-keyup" class="headerlink" title="3.5 键盘：keydown/keyup"></a>3.5 键盘：keydown/keyup</h3><h4 id="1-keydown-keyup"><a href="#1-keydown-keyup" class="headerlink" title="1. keydown/keyup"></a>1. keydown/keyup</h4><p>当一个按键被按下时，会触发 <code>keydown</code> 事件，而当按键被释放时，会触发 <code>keyup</code> 事件。</p>
<p><strong>event.code 和 event.key</strong></p>
<p>事件对象的 <code>key</code> 属性允许获取字符，而事件对象的 <code>code</code> 属性则允许获取“物理按键代码”。</p>
<p>尽管大多时候 code 和 key 的内容相同，但是有些时候code的内容更加精确，比如 shift 按键，code会明确告知是键盘左边的shift还是右边的shift。此外 key 获取是一个字符，它会随着语言的改变而改变，并且有些键盘之间相同的位置但是字符也有所不同，所以使用code更加合适。</p>
<h4 id="2-自动重复"><a href="#2-自动重复" class="headerlink" title="2. 自动重复"></a>2. 自动重复</h4><p>如果按下一个键足够长的时间，它就会开始“自动重复”：<code>keydown</code> 会被一次又一次地触发，然后当按键被释放时，我们最终会得到 <code>keyup</code>。因此，有很多 <code>keydown</code> 却只有一个 <code>keyup</code> 是很正常的。</p>
<p>对于由自动重复触发的事件，<code>event</code> 对象的 <code>event.repeat</code> 属性被设置为 <code>true</code>。</p>
<h4 id="3-默认行为"><a href="#3-默认行为" class="headerlink" title="3. 默认行为"></a>3. 默认行为</h4><p>默认行为各不相同，因为键盘可能会启动许多可能的东西。</p>
<p>例如：</p>
<ul>
<li>出现在屏幕上的一个字符（最明显的结果）。</li>
<li>一个字符被删除（Delete 键）。</li>
<li>滚动页面（PageDown 键）。</li>
<li>浏览器打开“保存页面”对话框（Ctrl+S）</li>
<li>……等。</li>
</ul>
<p>阻止对 <code>keydown</code> 的默认行为可以取消大多数的行为，但基于 OS 的特殊按键除外。例如，在 Windows 中，Alt+F4 会关闭当前浏览器窗口。并且无法通过在 JavaScript 中阻止默认行为来阻止它。</p>
<p>例如，下面的这个 <code>&lt;input&gt;</code> 期望输入的内容为一个电话号码，因此它不会接受除数字，<code>+</code>，<code>()</code> 和 <code>-</code> 以外的按键：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">checkPhoneKey</span>(<span class="hljs-params">key</span>) &#123;</span>
<span class="language-javascript">        <span class="hljs-keyword">return</span> (key &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; key &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) || key == <span class="hljs-string">&#x27;+&#x27;</span> || key == <span class="hljs-string">&#x27;(&#x27;</span> || key == <span class="hljs-string">&#x27;)&#x27;</span> || key == <span class="hljs-string">&#x27;-&#x27;</span>;</span>
<span class="language-javascript">    &#125;</span>
<span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onkeydown</span>=<span class="hljs-string">&quot;return checkPhoneKey(event.key)&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Phone, please&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;tel&quot;</span>&gt;</span></code></pre>

<h4 id="遗存"><a href="#遗存" class="headerlink" title="遗存"></a>遗存</h4><p>过去曾经有一个 <code>keypress</code> 事件，还有事件对象的 <code>keyCode</code>、<code>charCode</code> 和 <code>which</code> 属性。</p>
<p>大多数浏览器对它们都存在兼容性问题，以致使该规范的开发者不得不弃用它们并创建新的现代的事件（本文上面所讲的这些事件），除此之外别无选择。旧的代码仍然有效，因为浏览器还在支持它们，但现在完全没必要再使用它们。</p>
<h3 id="3-6-滚动"><a href="#3-6-滚动" class="headerlink" title="3.6 滚动"></a>3.6 滚动</h3><p><code>scroll</code> 事件允许对页面或元素滚动作出反应。</p>
<h4 id="防止滚动"><a href="#防止滚动" class="headerlink" title="防止滚动"></a>防止滚动</h4><p>我们不能通过在 <code>onscroll</code> 监听器中使用 <code>event.preventDefault()</code> 来阻止滚动，因为它会在滚动发生之后才触发。</p>
<p>但是我们可以在导致滚动的事件上，例如在 pageUp 和 pageDown 的 <code>keydown</code> 事件上，使用 <code>event.preventDefault()</code> 来阻止滚动。</p>
<h2 id="4-表单控件"><a href="#4-表单控件" class="headerlink" title="4. 表单控件"></a>4. 表单控件</h2><h3 id="4-1-表单属性和方法"><a href="#4-1-表单属性和方法" class="headerlink" title="4.1.表单属性和方法"></a>4.1.表单属性和方法</h3><h4 id="1-访问"><a href="#1-访问" class="headerlink" title="1. 访问"></a>1. 访问</h4><p>文档中的表单是特殊集合 <code>document.forms</code> 的成员。</p>
<p>这就是所谓的“命名的集合”：既是被命名了的，也是有序的。我们既可以使用名字，也可以使用在文档中的编号来获取表单。</p>
<pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">forms</span>.<span class="hljs-property">my</span> - name=<span class="hljs-string">&quot;my&quot;</span> 的表单
<span class="hljs-variable language_">document</span>.<span class="hljs-property">forms</span>[<span class="hljs-number">0</span>] - 文档中的第一个表单</code></pre>

<p>可能会有多个名字相同的元素，这种情况经常在处理单选按钮中出现。</p>
<p>在这种情况下，<code>form.elements[name]</code> 将会是一个集合</p>
<pre><code class="hljs js">form.<span class="hljs-property">elements</span>.<span class="hljs-property">age</span>[<span class="hljs-number">0</span>]; form表单中名为age的元素集合的第一个</code></pre>

<p><strong>Fieldset作为“子表单”</strong></p>
<p>一个表单内会有一个或多个 <code>&lt;fieldset&gt;</code> 元素。它们也具有 <code>elements</code> 属性，该属性列出了 <code>&lt;fieldset&gt;</code> 中的表单控件。</p>
<p><strong>更简短的表示方式：</strong><code>form.name</code></p>
<p>一般情况下，我们是通过<code>form.elements.login</code> 这种方式访问login，其实它支持更加简短的方式 <code>form.login</code>。</p>
<blockquote>
<p>我们是可以通过上面的方式修改表单的控件的 name 。</p>
</blockquote>
<h4 id="2-反向引用"><a href="#2-反向引用" class="headerlink" title="2. 反向引用"></a>2. 反向引用</h4><p>对于任何元素，其对应的表单都可以通过 <code>element.form</code> 访问到。因此，表单引用了所有元素，元素也引用了表单。</p>
<h4 id="3-表单元素"><a href="#3-表单元素" class="headerlink" title="3. 表单元素"></a>3. 表单元素</h4><p><strong>input 和 textarea</strong></p>
<p>我们可以通过 <code>input.value</code>（字符串）或 <code>input.checked</code>（布尔值）来访问复选框（checkbox）中的它们的 <code>value</code>。</p>
<blockquote>
<p>使用 <code>textarea.value</code> 而不是 <code>textarea.innerHTML</code>，尽管后者可以，但是正如前面所说，这是不安全的。</p>
</blockquote>
<p><strong>select 和 option</strong></p>
<p>一个 <code>&lt;select&gt;</code> 元素有 3 个重要的属性：</p>
<ol>
<li><code>select.options</code> —— <code>&lt;option&gt;</code> 的子元素的集合，</li>
<li><code>select.value</code> —— 当前所选择的 <code>&lt;option&gt;</code> 的 <code>value</code>，</li>
<li><code>select.selectedIndex</code> —— 当前所选择的 <code>&lt;option&gt;</code> 的编号。</li>
</ol>
<p>它们提供了三种为 <code>&lt;select&gt;</code> 设置 <code>value</code> 的不同方式：</p>
<ol>
<li>找到对应的 <code>&lt;option&gt;</code> 元素，并将 <code>option.selected</code> 设置为 <code>true</code>。</li>
<li>将 <code>select.value</code> 设置为对应的 <code>value</code>。</li>
<li>将 <code>select.selectedIndex</code> 设置为对应 <code>&lt;option&gt;</code> 的编号。</li>
</ol>
<h4 id="4-new-Option"><a href="#4-new-Option" class="headerlink" title="4. new Option"></a>4. new Option</h4><p>创建一个 &lt;option&gt; 元素：</p>
<pre><code class="hljs js">option = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Option</span>(text, value, defaultSelected, selected);</code></pre>

<p>参数：</p>
<ul>
<li><code>text</code> —— <code>&lt;option&gt;</code> 中的文本，</li>
<li><code>value</code> —— <code>&lt;option&gt;</code> 的 <code>value</code>，</li>
<li><code>defaultSelected</code> —— 如果为 <code>true</code>，那么 <code>selected</code> HTML-特性（attribute）就会被创建，</li>
<li><code>selected</code> —— 如果为 <code>true</code>，那么这个 <code>&lt;option&gt;</code> 就会被选中。</li>
</ul>
<p><code>&lt;option&gt;</code> 元素具有以下属性：</p>
<ul>
<li><p><code>option.selected</code></p>
<p>  <code>&lt;option&gt;</code> 是否被选择。</p>
</li>
<li><p><code>option.index</code></p>
<p>  <code>&lt;option&gt;</code> 在其所属的 <code>&lt;select&gt;</code> 中的编号。</p>
</li>
<li><p><code>option.text</code></p>
<p>  <code>&lt;option&gt;</code> 的文本内容（可以被访问者看到）。</p>
</li>
</ul>
<h3 id="4-2-聚焦"><a href="#4-2-聚焦" class="headerlink" title="4.2. 聚焦"></a>4.2. 聚焦</h3><h4 id="1-focus-blur事件"><a href="#1-focus-blur事件" class="headerlink" title="1. focus/blur事件"></a>1. focus/blur事件</h4><p>当元素聚焦时，会触发 <code>focus</code> 事件，当元素失去焦点时，会触发 <code>blur</code> 事件。</p>
<p>通常，我们在blur事件中进行输入校验</p>
<p>请注意，我们无法通过在 <code>onblur</code> 事件处理程序中调用 <code>event.preventDefault()</code> 来“阻止失去焦点”，因为 <code>onblur</code> 事件处理程序是在元素失去焦点 <strong>之后</strong> 运行的。</p>
<p><strong>Javascript导致的焦点丢失</strong></p>
<p>其中之一就是用户点击了其它位置。当然 JavaScript 自身也可能导致焦点丢失，例如：</p>
<ul>
<li>一个 <code>alert</code> 会将焦点移至自身，因此会导致元素失去焦点（触发 <code>blur</code> 事件），而当 <code>alert</code> 对话框被取消时，焦点又回重新回到原元素上（触发 <code>focus</code> 事件）。</li>
<li>如果一个元素被从 DOM 中移除，那么也会导致焦点丢失。如果稍后它被重新插入到 DOM，焦点也不会回到它身上。</li>
</ul>
<h4 id="2-允许在任何元素上聚焦：tabindex"><a href="#2-允许在任何元素上聚焦：tabindex" class="headerlink" title="2. 允许在任何元素上聚焦：tabindex"></a>2. 允许在任何元素上聚焦：tabindex</h4><p>默认情况下，很多元素不支持聚焦。</p>
<p>列表（list）在不同的浏览器表现不同，但有一件事总是正确的：<code>focus/blur</code> 保证支持那些用户可以交互的元素：<code>&lt;button&gt;</code>，<code>&lt;input&gt;</code>，<code>&lt;select&gt;</code>，<code>&lt;a&gt;</code> 等。</p>
<p>另一方面，为了格式化某些东西而存在的元素像 <code>&lt;div&gt;</code>，<code>&lt;span&gt;</code> 和 <code>&lt;table&gt;</code> —— 默认是不能被聚焦的。<code>elem.focus()</code> 方法不适用于它们，并且 <code>focus/blur</code> 事件也绝不会被触发。</p>
<p>使用 HTML-特性（attribute）<code>tabindex</code> 可以改变这种情况。任何具有 <code>tabindex</code> 特性的元素，都会变成可聚焦的。该特性的 <code>value</code> 是当使用 Tab（或类似的东西）在元素之间进行切换时，元素的顺序号。</p>
<p>这里有两个特殊的值：</p>
<ul>
<li><p><code>tabindex=&quot;0&quot;</code> 会使该元素被与那些不具有 <code>tabindex</code> 的元素放在一起。也就是说，当我们切换元素时，具有 <code>tabindex=&quot;0&quot;</code> 的元素将排在那些具有 <code>tabindex ≥ 1</code> 的元素的后面。</p>
<p>  通常，它用于使元素具有焦点，但是保留默认的切换顺序。使元素成为与 <code>&lt;input&gt;</code> 一样的表单的一部分。</p>
</li>
<li><p><code>tabindex=&quot;-1&quot;</code> 只允许以编程的方式聚焦于元素。Tab 键会忽略这样的元素，但是 <code>elem.focus()</code> 有效。</p>
</li>
</ul>
<h4 id="3-事件委托"><a href="#3-事件委托" class="headerlink" title="3. 事件委托"></a>3. 事件委托</h4><p><code>focus</code> 和 <code>blur</code> 事件不会向上冒泡。</p>
<p>这里有两个解决方案。</p>
<ul>
<li>方案一，有一个遗留下来的有趣的特性（feature）：<code>focus/blur</code> 不会向上冒泡，但会在捕获阶段向下传播。</li>
<li>方案二，可以使用 <code>focusin</code> 和 <code>focusout</code> 事件 —— 与 <code>focus/blur</code> 事件完全一样，只是它们会冒泡。</li>
</ul>
<p>值得注意的是，方案二必须使用 <code>elem.addEventListener</code> 来分配它们，而不是 <code>on&lt;event&gt;</code>。</p>
<h3 id="4-3-事件"><a href="#4-3-事件" class="headerlink" title="4.3 事件"></a>4.3 事件</h3><h4 id="1-change"><a href="#1-change" class="headerlink" title="1. change"></a>1. change</h4><p>当元素更改完成时，将触发 <code>change</code> 事件。</p>
<p>对于文本输入框，当其失去焦点时并且元素内容改变，就会触发 <code>change</code> 事件。</p>
<p>对于其它元素：<code>select</code>，<code>input type=checkbox/radio</code>，会在选项更改后立即触发 <code>change</code> 事件。</p>
<h4 id="2-input"><a href="#2-input" class="headerlink" title="2. input"></a>2. input</h4><p>每当用户对输入值进行修改后，就会触发 <code>input</code> 事件。</p>
<blockquote>
<p>当输入值更改后，就会触发 <code>input</code> 事件。所以，我们无法使用 <code>event.preventDefault()</code> —— 已经太迟了，不会起任何作用了。可以在onkeydown中阻止。</p>
</blockquote>
<h4 id="3-cut-copy-paste"><a href="#3-cut-copy-paste" class="headerlink" title="3. cut, copy, paste"></a>3. cut, copy, paste</h4><p>行为可以被阻止。<code>event.clipboardData</code> 属性可以用于读/写剪贴板。</p>
<p>但是请注意，剪贴板是“全局”操作系统级别的。安全起见，大多数浏览器仅在特定的用户行为下，才允许对剪贴板进行读/写，例如在 <code>onclick</code> 事件处理程序中。</p>
<p>并且，除火狐（Firefox）浏览器外，所有浏览器都禁止使用 <code>dispatchEvent</code> 生成“自定义”剪贴板事件。</p>
<h3 id="4-4-表单提交"><a href="#4-4-表单提交" class="headerlink" title="4.4 表单提交"></a>4.4 表单提交</h3><p>提交表单时，会触发 <code>submit</code> 事件，它通常用于在将表单发送到服务器之前对表单进行校验，或者中止提交，并使用 JavaScript 来处理表单。</p>
<h4 id="1-事件：submit"><a href="#1-事件：submit" class="headerlink" title="1. 事件：submit"></a>1. 事件：submit</h4><p>提交表单主要有两种方式：</p>
<ol>
<li>第一种 —— 点击 <code>&lt;input type=&quot;submit&quot;&gt;</code> 或 <code>&lt;input type=&quot;image&quot;&gt;</code>。</li>
<li>第二种 —— 在 <code>input</code> 字段中按下 Enter 键。</li>
</ol>
<p><strong>submit 和 click 的关系</strong></p>
<p>在输入框中使用 Enter 发送表单时，会在 <code>&lt;input type=&quot;submit&quot;&gt;</code> 上触发一次 <code>click</code> 事件。</p>
<p>这很有趣，因为实际上根本没有点击。</p>
<h4 id="2-方法：submit"><a href="#2-方法：submit" class="headerlink" title="2. 方法：submit"></a>2. 方法：submit</h4><p>如果要手动将表单提交到服务器，我们可以调用 <code>form.submit()</code>。</p>
<p>这样就不会产生 <code>submit</code> 事件。这里假设如果开发人员调用 <code>form.submit()</code>，就意味着此脚本已经进行了所有相关处理。</p>
<h2 id="5-加载文档和其它资源"><a href="#5-加载文档和其它资源" class="headerlink" title="5. 加载文档和其它资源"></a>5. 加载文档和其它资源</h2><h3 id="5-1-页面生命周期"><a href="#5-1-页面生命周期" class="headerlink" title="5.1 页面生命周期"></a>5.1 页面生命周期</h3><p>HTML 页面的生命周期包含三个重要事件：</p>
<ul>
<li><code>DOMContentLoaded</code> —— 浏览器已完全加载 HTML，并构建了 DOM 树，但像 <code>&lt;img&gt;</code> 和样式表之类的外部资源可能尚未加载完成。</li>
<li><code>load</code> —— 浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等。</li>
<li><code>beforeunload/unload</code> —— 当用户正在离开页面时。</li>
</ul>
<p>每个事件都是有用的：</p>
<ul>
<li><code>DOMContentLoaded</code> 事件 —— DOM 已经就绪，因此处理程序可以查找 DOM 节点，并初始化接口。</li>
<li><code>load</code> 事件 —— 外部资源已加载完成，样式已被应用，图片大小也已知了。</li>
<li><code>beforeunload</code> 事件 —— 用户正在离开：我们可以检查用户是否保存了更改，并询问他是否真的要离开。</li>
<li><code>unload</code> 事件 —— 用户几乎已经离开了，但是我们仍然可以启动一些操作，例如发送统计数据。</li>
</ul>
<h4 id="1-DOMContentLoaded"><a href="#1-DOMContentLoaded" class="headerlink" title="1. DOMContentLoaded"></a>1. DOMContentLoaded</h4><p>在进行页面加载时，如果在文档中遇到&lt;script&gt; ，它会直接运行，之后才会继续构建DOM，这样做的原因时我们可能在脚本中修改DOM。</p>
<p><strong>不会阻塞 DOMContentLoaded 的脚本</strong></p>
<p>此规则有两个例外：</p>
<ol>
<li>具有 <code>async</code> 特性（attribute）的脚本不会阻塞 <code>DOMContentLoaded</code>，<a href="https://zh.javascript.info/script-async-defer">稍后</a> 我们会讲到。</li>
<li>使用 <code>document.createElement(&#39;script&#39;)</code> 动态生成并添加到网页的脚本也不会阻塞 <code>DOMContentLoaded</code>。</li>
</ol>
<p>外部样式表不会影响 DOM，因此 <code>DOMContentLoaded</code> 不会等待它们。</p>
<p>但这里有一个陷阱。如果在样式后面有一个脚本，那么该脚本必须等待样式表加载完成。</p>
  
        </div>
    </div>
</div>


    
<script src="../../../js/index.js"></script>

  </body>
</html>
